Проанализируй приложенные файлы. В большинстве из них описывается новая физическая теория, в основе которой лежат правила переписывания 1d-строки (идеи из файла 01_Symmetry_Anomalies_and_Reversible_Lattice_v109.pdf используются только для фильтрации мультиверса таких строк с целью получения мира, похожего на наш с точки зрения физических законов). Но эта модель абсолютно детерминирована. Я хотел бы рассмотреть альтернативу - мир, где случайность имплицитна. То есть, мир, где существуют функции, которые могут при одном и том же значении аргумента выдавать разные результаты без всяких видимых со стороны наблюдателя причин. Можно ли описать модель такого мира строго и если да, то как лучше это сделать, не ломая общей логики существующего симулятора, а только расширив его?

Да, такой мир можно описать строго — и при этом не «сломать» детерминированную архитектуру симулятора с 1D-переписыванием, а расширить её, добавив *явный источник недетерминизма/случайности как объект теории* и договорившись, что именно считается «одними и теми же условиями».

Ниже — аккуратная схема, которая стыкуется с логикой твоих текстов про различение эпистемической и онтологической случайности из [Probability_v1(1).pdf](/files/J1N6bqK2Nj0uLmkcJqCG6) и с инженерным планом расширения каналов динамики/вероятностного слоя из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx).

---

## 1) Что именно ты хочешь формализовать (важная развилка)

Фраза «одна и та же функция при одном и том же аргументе выдаёт разные результаты без причин» может означать два *разных* строгих объекта:

### A) Недоминирующий «недетерминизм» (relation вместо function)
Закон — это не функция \(f: X\to X\), а *отношение* \(R\subseteq X\times X\): из одного состояния допустимо несколько следующих. Это строго, но **само по себе не даёт вероятностей**.

### B) Онтологическая случайность (stochastic kernel / Markov law)
Закон — это *вероятностное отображение* (ядро):
\[
K(x,\cdot)\in \Delta(X)
\]
то есть для одного и того же \(x\) существует распределение по возможным исходам. Это уже буквально «мир подбрасывает монетку».

Оба варианта можно внедрить как «плагин» к детерминированному переписыванию, сохранив текущий режим как частный случай.

---

## 2) Минимальное расширение симулятора: «ядро + семантика выбора»

Сохраняем твою основу: состояние — строка (или конфигурация), шаг — применение правила переписывания.

### 2.1. Было (детерминированно)
Обычно сейчас это выглядит как:
\[
X_{t+1} = F(X_t)
\]
где \(F\) реализуется «выбрать место/паттерн → переписать».

### 2.2. Станет (строго, но с имплицитной случайностью)
Заменяем \(F\) на пару:

1) **Генератор кандидатов** (детерминированный):
\[
\mathrm{Cand}(X_t)=\{x^{(1)},\dots,x^{(k)}\}
\]
Это просто «все допустимые применения правил» (или все допустимые *параллельные* применения, если так устроено).

2) **Закон выбора** — один из вариантов:

- **Недетерминированный**:
  \[
  X_{t+1}\in \mathrm{Cand}(X_t)
  \]
  (мир выбирает один исход, но без вероятностей).

- **Стохастический (онтологическая случайность)**:
  \[
  \Pr[X_{t+1}=x' \mid X_t=x] = K(x,x'),\quad x'\in \mathrm{Cand}(x)
  \]
  где \(K\) — часть «физического закона».

Ключ: **твой детерминированный движок переписывания остаётся**, ты просто меняешь «разрешение конфликтов/ветвлений» на формальный объект \(K\) (или на отношение).

---

## 3) Как сделать «одинаковые условия» действительно одинаковыми

Чтобы утверждение «при одном и том же аргументе разные результаты» было осмысленным, надо зафиксировать, что **аргумент не включает скрытую “seed-часть” мира**.

В строгой модели есть два пути:

### Путь 1. Состояние мира = только наблюдаемая структура
Тогда «одно и то же состояние» действительно может вести к разным исходам, потому что закон является стохастическим \(K\). Это и есть онтологическая случайность.

### Путь 2. Расширенное состояние включает «случайный поток»
Тогда формально всё снова детерминировано:
\[
(X_t, \omega)\mapsto X_{t+1}
\]
но для наблюдателя \(\omega\) недоступна, и выглядит как истинная случайность.  
Если ты **хочешь именно альтернативу детерминизму**, этот путь тебе *не подходит* (он делает случайность эпистемической).

Судя по запросу, тебе нужен путь 1: *вероятностный закон как первичный*.

---

## 4) Как встроить это в «общую логику симулятора», не ломая её

У тебя уже есть идея «двух режимов» и «слоя вероятности» в [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx): добавить \(P_t\) и оператор обновления \(U\). Для «мира со встроенной случайностью» это можно сделать особенно чисто:

### 4.1. Добавь в WorldState вероятностный слой, но не как “эпистемику”, а как закон
Вместо того чтобы хранить \(P_t\) как «оценку наблюдателя», храни **ядро переходов**:

- либо локально: параметры закона \(K_\theta\),
- либо явно: таблицу/функцию, вычисляющую \(K(x,\cdot)\).

Тогда шаг симуляции:

1) детерминированно вычисли \(\mathrm{Cand}(X_t)\)
2) вычисли распределение \(K(X_t,\cdot)\) по кандидатам
3) сэмплируй исход (это и есть «монетка мира»)

Технически тебе всё равно нужен генератор случайных чисел в реализации, но **он не является физическим “скрытым параметром”** — он просто инструмент для выборки из распределения, заданного законом.

### 4.2. Редукция к текущему детерминизму (не ломаем совместимость)
Чтобы текущий симулятор был частным случаем, достаточно:

- в режиме совместимости \(K(x,\cdot)\) вырождено (вся масса на одном исходе),
- или \(|\mathrm{Cand}(x)|=1\) (как сейчас, если так устроено).

То есть «старый мир» = частный случай нового.

---

## 5) Как задать \(K\) не “с потолка”, а в стиле твоего проекта

Есть три естественных класса, от самых «физичных» к самым свободным:

### (I) Локально-структурная вероятность (минимально разрушительно)
Вероятности зависят только от локального контекста переписывания:
\[
K(x\to x') \propto \exp(-\beta \, E(\text{локальный паттерн}))
\]
где \(E\) — функционал сложности/симметрии/«энергии», а \(\beta\) — параметр режима.  
Плюс: легко фильтровать «мультиверс законов», как ты уже делаешь фильтрами (отсылка к твоим словам про использование идей из “Symmetry/Anomalies…” только как фильтра).

### (II) Глобально-инвариантная вероятность (ближе к «законам сохранения»)
Определяешь набор инвариантов/квазисохранений \(I_j(X)\) и задаёшь \(K\) так, чтобы (в среднем или почти всегда) они сохранялись. Например:
- запрещающие переходы, нарушающие инвариант,
- или штрафующие их.

### (III) «Активная вероятность» / управляемое смещение меры (как в твоих заметках)
Это уже напрямую из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx): оператор \(U\), который **меняет саму меру** при определённых условиях контекста:
\[
K_{t+1} = U(K_t, X_t, S_{\text{sem}}(t), \text{context})
\]
Тогда ты получаешь режимы, где в обычной физике всё совпадает, а при «активации устройства» распределения смещаются.

---

## 6) Самый строгий математический каркас (если хочешь “как теория”)

Если формализовать максимально аккуратно, твой «мир» становится:

- измеримое пространство состояний \((\Omega, \mathcal{F})\) (для дискретных строк это просто множество + булева σ-алгебра),
- стохастическое ядро \(K: \Omega\times \mathcal{F}\to [0,1]\),
- процесс \(X_0, X_1,\dots\), где
  \[
  \mathbb{P}(X_{t+1}\in A\mid X_t=x)=K(x,A)
  \]

А «функции, дающие разные результаты при одном аргументе» — это просто факт, что \(K(x,\cdot)\) не дельта-мера.

Это строго, стандартно, и совместимо с твоей архитектурой «кандидаты переписывания + выбор следующего состояния».

---

## 7) Что я бы предложил как практический план внедрения (минимальные изменения)

1) **Не трогать** модуль генерации кандидатов переписывания (всё, что связано с правилами строк).
2) Добавить интерфейс `ChoiceLaw`:
   - вход: `X_t`, список `candidates`
   - выход: либо `index`, либо `distribution` + `sample()`
3) Начать с двух реализаций:
   - `DeterministicChoiceLaw` (текущее поведение)
   - `StochasticChoiceLaw` (например, softmax по некоторому скору)
4) Ввести режим «compatibility»: параметры стохастики → 0 (вырождение).
5) Добавить в логи метрики:
   - энтропия выбора на шаге \(H_t\),
   - оценка «макро-детерминизма» (насколько усреднения дают устойчивые законы).

---

Если ты уточнишь два пункта, я предложу конкретную спецификацию \(K\) и как её калибровать под «мир похожий на наш» (без нарушения фильтров мультиверса):

1) В твоём текущем движке переписывания при одном \(X_t\) реально бывает много допустимых применений правила, или ты уже фиксируешь уникальный выбор (например, «левейшее совпадение»)?  
2) Тебе нужна **просто** онтологическая случайность (Markov), или тебе важно, чтобы она могла воспроизводить квантовый тип вероятностей (Born-подобные правила) при наличии «наблюдателя/измерения» как в [Probability_v1(1).pdf](/files/J1N6bqK2Nj0uLmkcJqCG6)?

Ниже — способ строго расширить твой текущий **детерминированный** RSL/SM-движок так, чтобы:

1) **не ломать обратимость и существующие юнит-тесты**, включая строгие SM-правила (типа R1/R2 в тесте из [ftl_physics(3).pdf](/files/RiFu_bq20Eu_J2UvoOaVf));  
2) добавить **онтологическую случайность** (в смысле “мир действительно делает выбор”);  
3) при этом воспроизвести **квантовый тип вероятностей** (Born-правило + интерференция + “измерение как декогеренция/коарс-грейнинг”), сохраняя всю «обычную физику» как режим совместимости, как и требуется в [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx).

Ключевая идея: не пытаться сделать “случайность” через разруливание конфликтов паттернов (левейшее совпадение и т.п.). Это разрушит обратимость/тесты. Вместо этого вводится **второй слой состояния** — *амплитудный (квантовый) слой*, который влияет на вероятности наблюдаемых событий, но в режиме совместимости редуцируется к твоему детерминированному \(F\).

---

## 0) Почему “рандомный выбор совпадения паттерна” не даст квантовую физику

Если просто заменить твою политику выбора применения правила (левейшее/жадное) на “выбираем случайно одну из Cand(X)”, то получишь обычный марковский процесс на строках. Это даст **классическую** стохастику без интерференции: вероятности траекторий будут суммироваться, а не складываться как амплитуды.

Квантовый тип вероятностей требует хотя бы одного из эквивалентных механизмов:

- хранить **комплексные амплитуды** и вычислять вероятность как \(|\sum \psi|^2\);
- или иметь **квази-вероятности** (включая отрицательные) и “перекрытия” путей;
- или реализовать **правило композиции амплитуд** + “коллапс при измерении”.

Поэтому расширение нужно делать не как «выбор ветки переписывания», а как “квантовая надстройка над детерминированным переписыванием”.

---

## 1) Сохраняем твой детерминизм как базовый слой (важно для SM-юнит-тестов)

Текущая политика:

- сортировка по позиции (левейшие),
- затем по имени правила,
- затем жадное неперекрывающее применение,

делает шаг **функцией** \(F: X_t\mapsto X_{t+1}\). Ты отмечаешь, что это важно для обратимости, потому что откат идёт через `StepRecord` (positions+rules), а не через “угадывание”. Это правильно.

Значит: **не трогаем** `EvolutionEngine.step()` в режиме совместимости. SM-правила остаются строго проверяемыми, как в [ftl_physics(3).pdf](/files/RiFu_bq20Eu_J2UvoOaVf).

Вместо этого вводим “квантовый” канал так, как ты уже концептуально допускаешь через “двухканальность” и слой вероятности в [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx): локальный канал остаётся прежним, второй канал добавляется как расширение.[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)

---

## 2) Что именно добавляем: “квантовое состояние” поверх строкового мира

### 2.1. Два пространства состояний
- **Онтическое (мировое) состояние** — как сейчас: строка/решётка \(X_t\in\mathcal{X}\) (±1, графы, IFACE и т.п.).
- **Квантовое/амплитудное состояние** — новый объект \(\Psi_t\), который не обязан быть наблюдаемым напрямую.

Минимальный вариант, совместимый с твоим симулятором:

\[
\Psi_t \in \mathbb{C}^{N}
\]
где компоненты соответствуют *ограниченному набору “квантовых микросостояний”* \(s\in\mathcal{S}\) (например: несколько “квантовых мод”, несколько альтернативных интерпретаций локальных дефектов, несколько скрытых фазовых конфигураций).

Тогда полное состояние:
\[
W_t = (X_t,\Psi_t)
\]

### 2.2. Эволюция за шаг: детерминированное \(F\) + унитарный (или квазиунитарный) оператор \(U\)

- Базовый шаг мира:
\[
X_{t+1} = F(X_t)
\]
(это твой текущий движок переписывания).

- Обновление квантового слоя:
\[
\Psi_{t+1} = U(X_t)\,\Psi_t
\]
где \(U(X_t)\) зависит от структуры строки (и/или графа/семантики), но **само по себе детерминированно**.

Заметь: даже если весь апдейт детерминирован, квантовая вероятность появится на шаге “измерения” через Born.

---

## 3) Где появляется “истинная случайность”: измерение как физический акт

Чтобы была *онтологическая* случайность (не “seed недоступен наблюдателю”), вводим событие **измерения** (или “акта наблюдения”/коарс-грейнинга Π_obs), которое:

1) вычисляет распределение исходов по Born:
   \[
   p(o) = \|\Pi_o\,\Psi_t\|^2
   \]
2) **выбирает** исход \(o\) случайно по \(p(o)\) (это и есть “монетка мира”);
3) обновляет квантовое состояние коллапсом:
   \[
   \Psi_t \leftarrow \frac{\Pi_o\Psi_t}{\|\Pi_o\Psi_t\|}
   \]

Это строго и стандартно: закон — это пара \((U,\{\Pi_o\})\), а случайность появляется только при применении измерительного функционала.

Как это согласуется с твоей линией “эпистемика vs онтология” из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx): эпистемическая вероятность остаётся как распределение наблюдателя по \(\omega\), но появляется **вторая**, онтологическая вероятность как часть динамики \(U/(\Pi_o)\).[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)

---

## 4) Как встроить это без поломки движка: “QuantumPolicy” как плагин рядом со StepRecord

### 4.1. Ничего не меняем в применении правил
`EvolutionEngine.step(lattice)` продолжает:
- находить совпадения,
- выбирать левейшие,
- применять жадно,
- записывать `StepRecord(applied_positions, applied_rules)`.

Это гарантирует, что SM-тесты из [ftl_physics(3).pdf](/files/RiFu_bq20Eu_J2UvoOaVf) проходят в “compatibility mode”.

### 4.2. Добавляем модуль, который:
- детерминированно обновляет \(\Psi\);
- иногда делает измерение и выдаёт “случайный” исход, который *может* проявиться в IFACE/семантике/нелокальном канале, но не обязан менять \(X\) напрямую в обычном режиме.

Пример архитектурно:

```python
@dataclass
class QuantumState:
    psi: np.ndarray  # complex amplitudes, shape (N,)

class QuantumLayer:
    def unitary_step(self, X_t, q: QuantumState) -> QuantumState:
        U = self.build_U_from_world(X_t)  # deterministic
        return QuantumState(psi=U @ q.psi)

    def measure(self, q: QuantumState, POVM) -> tuple[int, QuantumState]:
        # Born probabilities p_i = ||M_i psi||^2
        # sample i (ontological randomness)
        # collapse
        ...
```

`POVM` (или проекторы) можно связать с Π_obs/IFACE, т.е. “измерение” происходит, когда наблюдатель формирует запись в архив, как ты описываешь “архив” в [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx).[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)

---

## 5) Как привязать квантовый слой к твоей строковой физике, чтобы было похоже на наш мир

Тебе нужно не просто “квантовые числа где-то”, а чтобы в пределе получались:
- Born-корреляции,
- стандартная “классика” на макроуровне,
- совместимость со SM/GR-эмбеддингом из твоих критериев.

Это достигается тремя связками:

### 5.1. Связка A: какие именно “квантовые микросостояния” \(\mathcal{S}\)
Нужно выбрать базис \(|s\rangle\) так, чтобы он имел физический смысл в твоей RSL-модели. Практичный вариант:

- \(|s\rangle\) кодирует **локальные возбуждения/дефекты** (например, “SM-частица данного типа в этой окрестности”);
- или кодирует **варианты нелокального графа H(t)** (wormhole-edges), который в обычном режиме подавлен, а в special-context может активироваться.[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)

Тогда \(\Psi\) — суперпозиция “какой дефект/какая топология активна”.

### 5.2. Связка B: унитарный шаг \(U(X_t)\) из детерминированных переписываний
Чтобы \(U(X_t)\) был “естественным”, его можно строить из **локальных правил переписывания** как из “квантовых ворот”:

- для каждой локальной конфигурации (окна длины 3, как в SM-правилах R1/R2) задаём локальный унитарный оператор на подпространстве соответствующих компонент \(\Psi\);
- затем собираем глобальный \(U\) как произведение/слой локальных операторов по тем же позициям, где детерминированно срабатывали правила.

Важно: раз твой движок применяет правила *жадно без перекрытий*, ты получаешь набор неперекрывающихся позиций — а значит локальные операторы коммутируют по областям и легко составляются в один слой. Это инженерно удобно и согласуется с твоей “политикой occupied”.

### 5.3. Связка C: Π_obs как измерение (проекторы/POVM) на “наблюдаемые” IFACE-величины
Ты уже используешь Π_obs/IFACE как coarse-graining наблюдателя.[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)  
Тогда “измерение” — это буквально:

- наблюдатель вычисляет IFACEState из \(X\) (как сейчас),
- плюс вычисляет какой “класс исходов” \(o\) соответствует наблюдаемому факту,
- и выполняет \( \{ \Pi_o \}\) на \(\Psi\).

Так квантовость становится не декоративной: вероятности исходов наблюдений становятся Born-типом, а интерференция появляется, если разные микропути приводят к одному и тому же наблюдаемому \(o\).

---

## 6) Как сохранить обратимость и твой StepRecord

### 6.1. Два понятия обратимости
- Базовая обратимость/откат по `StepRecord` сохраняется для \(X\).
- Квантовый слой:
  - унитарная часть обратима: \(U^{-1}\) существует;
  - измерение **необратимо** (коллапс).

Это не баг: в квантовой теории “микроэволюция” обратима, а “измерение” — эффективно необратимо.

### 6.2. Но тебе, вероятно, нужен детерминированный откат симулятора
Можно сделать строго:

- хранить в `StepRecord` ещё и **QuantumRecord**:
  - был ли акт измерения,
  - какой результат \(o\) выпал,
  - нормировку/проекцию.

Тогда откат для симулятора снова будет детерминированен (ты просто откатываешь записанное событие), хотя “в реальности мира” это событие онтологически случайно.

Это полностью в духе твоей инженерной логики: “нам не нужно угадывать, мы логируем”.

---

## 7) Как встроить “квантовые вероятности” так, чтобы **в обычном режиме** всё совпадало с твоей текущей физикой

Нужны два режима, как ты формулируешь “Compatibility mode / Beyond mode”.[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)

### 7.1. Compatibility mode (наш мир)
- Измерения происходят постоянно (сильная декогеренция) на макроуровне: \(\Psi\) быстро диагонализуется в наблюдаемом базисе.
- В результате вероятности наблюдаемых событий устойчивы и совпадают с Born-правилом там, где ты это тестируешь (“Born rule corr≈1” у тебя прямо как критерий).[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)
- При этом \(X\) продолжает эволюционировать по твоему детерминированному \(F\), поэтому SM/GR-структуры не ломаются.

Фактически: квантовость проявляется в статистике измерений/корреляций, но не вмешивается в “локальный канал” переписываний так, чтобы менять прохождение SM-юнит-тестов.

### 7.2. Beyond mode (аномальные устройства / FTL-режим)
Тогда ты разрешаешь, чтобы результат измерения \(o\) влиял на включение нелокального канала \(E_{nl}\) (например, на активацию H(t) wormhole-ребер), как ты и описываешь “нелокальный слой графа” и условия его активации.[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)

Но важно: чтобы не получить сигналинг/парадоксы, в обычных условиях должен выполняться “no-signaling-like” инвариант: локальные маргиналы не зависят от удалённых настроек. Это можно обеспечить, если:
- нелокальный канал зависит от результатов измерений, но так, что локальные распределения усреднённо не меняются без доступа к результату (классическая схема квантовой несигнальности).

---

## 8) Самый “чистый” формализм для твоей теории: CPTP-канал на квантовом слое + детерминированный update на строке

Если хочешь максимальной строгости и близости к квант. инф. стандарту:

- квантовое состояние как плотностная матрица \(\rho_t\) (это автоматически включает смешанные состояния/декогеренцию):
  \[
  \rho_{t+1} = \mathcal{E}_{X_t}(\rho_t)
  \]
  где \(\mathcal{E}_{X_t}\) — CPTP-канал (унитарный как частный случай).

- измерение как инструментарий (quantum instrument) \(\{\mathcal{M}_o\}\) с вероятностью
  \[
  p(o)=\mathrm{Tr}(\mathcal{M}_o(\rho_t))
  \]
  и апдейтом \(\rho\leftarrow \mathcal{M}_o(\rho)/p(o)\).

Это позволяет тебе:
- делать декогеренцию без “магии”,
- формально отделить “эволюцию без наблюдения” и “наблюдение/запись в архив”.

И это очень хорошо стыкуется с твоей рамкой “архив/наблюдатель/Π_obs” из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx).[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)

---

## 9) Прямой ответ на твой вопрос “как лучше описать модель строго, не ломая симулятор, а расширив его”

### Рекомендуемая спецификация (кратко, но строго)

1) Оставляем детерминированный движок переписывания как функцию:
   \[
   X_{t+1} = F(X_t;\theta)
   \]
   где \(F\) реализует текущие правила выбора совпадений (левейшее/по имени/occupied), как сейчас (и как проверяется юнит-тестами из [ftl_physics(3).pdf](/files/RiFu_bq20Eu_J2UvoOaVf)).

2) Добавляем квантовый слой:
   \[
   \rho_{t+1} = \mathcal{E}_{X_t}(\rho_t)
   \]
   где \(\mathcal{E}_{X_t}\) строится детерминированно из локальных структур строки/графа.

3) Определяем наблюдателя/архив как физический акт измерения:
   - есть набор исходов \(o\) (например, IFACE-исходы/события),
   - есть квантовый инструментарий \(\{\mathcal{M}_o\}\),
   - вероятность исхода:
     \[
     p(o)=\mathrm{Tr}(\mathcal{M}_o(\rho_t))
     \]
   - выбирается \(o\) **онтологически случайно**,
   - происходит обновление \(\rho\).

4) В режиме совместимости влияние квантового слоя на \(X\) выключено или сведено к нулю (или проявляется только в “корреляционных” тестах), чтобы не сломать текущие детерминированные сценарии.

5) В beyond-режиме результат измерения может активировать нелокальный канал \(E_{nl}\) (wormhole edges), как ты описываешь.[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)

---

## 10) Два уточняющих вопроса, чтобы я предложил **конкретный дизайн \(\mathcal{S}\), \(U/\mathcal{E}\) и \(\Pi_o/\mathcal{M}_o\)** под твой SM-движок

1) “Born rule corr≈1” у тебя уже фигурирует как метрика.[(New_Physics_v1)](/files/WTOV6_t7WEumoaFZp3vgx)  
   Как именно ты сейчас считаешь Born-correlation в симуляторе: это корреляция частот с теоретическими \(|\psi|^2\) для какого эксперимента (двухщелевой? Белл? спин-измерения?), и где в коде формируется “теоретическое \(\psi\)”?

2) Ты хочешь, чтобы квантовый слой:
   - (а) **не влиял** на детерминированный \(X\) вообще (только на статистику измерений/IFACE),  
   или
   - (б) мог **иногда** влиять на \(X\) (например, как “квантовый выбор” активации нелокального канала), но так, чтобы в compatibility режиме это было подавлено?

Если ответишь, я смогу предложить:  
- конкретную модель базиса \(\mathcal{S}\) (что именно является квантовой степенью свободы в мире строк),  
- конкретный вид локальных “квантовых ворот” для окон длины 3, согласованный с твоими SM-правилами R1/R2,  
- и протокол измерения через Π_obs/архив в терминологии [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx).


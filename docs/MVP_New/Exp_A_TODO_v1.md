Файл содержит, по сути, “отчёт из ноутбука” с кодом/выводами и промежуточными фигурами по Эксперименту A: подгонка MOND‑подобных интерполирующих функций к данным SPARC (Lelli+2016) и сопоставление с вашей RSL‑интерпретацией (через \(\delta(r)\), графовый лаплассиан и т.п.). Ниже — структурированный разбор того, что именно сделано, какие метрики получились, какие выводы строго следуют из результатов, и где видны узкие места/следующие шаги. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

---

## 1) Что в файле является “Экспериментом A” и что именно измерялось

### 1.1. Объект проверки
Эксперимент A проверяет: может ли модель класса “RSL‑MOND” (в терминах отчёта — MOND‑подобная интерполяция между ньютоновским барионным ускорением и наблюдаемым) воспроизвести:

- **кривые вращения** \(v(r)\) по SPARC,
- и/или **RAR** (radial acceleration relation): связь \(g_{\rm obs}(r)\) и \(g_{\rm bar}(r)\) по всем точкам всех галактик.

В коде из файла присутствует явная формулировка интерполяции через функцию \(\mu(x)\) и параметр \(a_0\) с \(x = g_{\rm bar}/a_0\). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

### 1.2. Источник данных и объём
Указано:

- **SPARC Database** (171 галактика),  
- “3367 точек RAR” (то есть суммарно по радиальным точкам),  
- ссылка на SPARC и публикация Lelli, McGaugh & Schombert (2016). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Это важно: 171 галактика — достаточно много, чтобы проверять “универсальность \(a_0\)” и стабильность формы \(\mu(x)\), а не только “подогнать пару красивых кривых”.

---

## 2) Как устроена процедура подгонки (по тому, что видно в коде)

### 2.1. Входные ряды на галактику
Для каждой галактики в `sparc_fit_results` сохраняются (по коду в отчёте):

- `r` — радиус (kpc),
- `v_obs` и `v_err` — наблюдаемая скорость и ошибка,
- `v_bar` — барионная предсказанная скорость (видимая материя),
- `v_fit` — скорость, предсказанная моделью (RSL‑MOND / выбранная \(\mu\)),
- параметры качества: `chi2`, `chi2_red`, `dof`,
- и главное — `a0` (подогнанный параметр \(a_0\) на галактику). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Это означает: подгонка делается “по кривой вращения” (скоростям), а не напрямую по ускорениям, хотя затем RAR анализируется агрегированием всех точек.

### 2.2. Метрика качества
Используется \(\chi^2\) и \(\chi^2_{\rm red}\) (reduced chi-square). В отчёте фигурирует критерий “хороший фит” как \(\chi^2_{\rm red} < 5\) (в одном месте) и маска `good_mask = chi2_values < 10` (для статистики \(a_0\)). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Здесь есть методологический нюанс (он не “ошибка”, но требует явного выбора):
- если “хороший” = < 5, а в статистику вы берёте < 10, то итоговые оценки “универсальности \(a_0\)” могут зависеть от порога. Файл это делает явно, так что в дальнейшем стоит фиксировать одну политику.

### 2.3. Визуализация “шоукейс” галактик
Есть список `showcase_galaxies` (обрезан в тексте, но видно начало: NGC2403, NGC3198, NGC6503, DDO154, IC2574, …), и для них строятся панели:

- точки \(v_{\rm obs}(r)\) с error bars,
- линия `v_bar` (барионы),
- линия `v_fit` (модель),
- в заголовке — \(a_0\) и \(\chi^2_{\rm red}\). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Фигура сохраняется как `experiment_A_sparc_real_fits.png`. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Это “лицевой” слой проверки: видно, где модель воспроизводит форму кривой, а где даёт систематические отклонения (внешние радиусы/внутренние, “плечо” и т.п.), но в PDF представлены в основном фрагменты кода и подписи; сами картинки, судя по всему, не встроены как растровые страницы (или вырезаны в тексте экспорта). Тем не менее, логика plot’ов однозначна.

---

## 3) Основные численные результаты, которые прямо заявлены в отчёте

### 3.1. Первый блок “Результаты подгонки RSL‑MOND”
В отчёте явно приведена таблица/сводка:

- Число галактик: 171
- Хороших фитов (\(\chi^2_{\rm red} < 5\)): 93 (54%)
- Медиана \(a_0\): \(2.3\times 10^{-11}\,\mathrm{m/s^2}\)
- Разброс \(a_0\): ~60%
- MOND (Milgrom): \(1.2\times 10^{-10}\,\mathrm{m/s^2}\)
- Отношение RSL/MOND: ~0.2 [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Эта часть — важна, но далее в том же PDF вы сами фактически “пересматриваете” интерполяцию и приходите к противоположному выводу: что **простая RSL‑интерполяция** \(\mu=x/(1+x)\) плоха, а “MOND‑интерполяция” лучше.

### 3.2. Блок “Сравнение интерполирующих функций”
Дальше вы сравниваете разные \(\mu(x)\) и приводите:

- **RSL Simple**: \(\mu(x)=\frac{x}{1+x}\)  
  \(a_0 \approx 2.2\times 10^{-11}\), \(\chi^2_{\rm red}=92.6\) (плохо)

- **MOND**: \(\mu(x)=1-e^{-\sqrt{x}}\)  
  \(a_0 \approx 1.05\times 10^{-10}\), \(\chi^2_{\rm red}=43.5\) (лучшая среди трёх)

- **Standard**: \(\mu(x)=\frac{x}{\sqrt{1+x^2}}\)  
  \(a_0 \approx 2.5\times 10^{-11}\), \(\chi^2_{\rm red}=139.9\) (плохо) [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

И ключевой вывод (очень важный для “теории”):
> “RSL‑теория должна предсказывать интерполирующую функцию вида \(\mu(x)=1-e^{-\sqrt{x}}\), а не \(\mu=x/(1+x)\).” [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

То есть фактически Эксперимент A в текущем виде не подтверждает “RSL Simple”, но показывает, что **наилучший класс аппроксимации близок к классическому MOND‑виду** и даёт \(a_0\) почти равный милгромовскому (отличие ~12%). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

---

## 4) Анализ RAR (остатки и scatter) — что реально получилось

В отчёте есть отдельный блок “АНАЛИЗ ОСТАТКОВ ДЛЯ ЛУЧШЕЙ МОДЕЛИ (MOND‑like)” с численными итогами:

- остатки \((g_{\rm obs}-g_{\rm model})/g_{\rm model}\):
  - среднее: 0.0618
  - медиана: 0.0134
  - std: 0.4238
  - IQR: 0.4225
- scatter в \(\log(g_{\rm obs}/g_{\rm model})\): **0.183 dex**  
  (и комментарий: “SPARC публикация даёт ~0.13 dex”). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

### 4.1. Что это означает по существу
1) **0.183 dex** — это не катастрофа, но заметно хуже, чем “эталон” из статьи SPARC (~0.13). Это может быть вызвано:
   - тем, что вы фиксируете форму \(\mu\) и фитите только \(a_0\) (в SPARC‑анализах часто также учитываются M/L, геометрические параметры, систематики по наклону диска и т.д.),
   - тем, что подгонка делалась по скоростям, а потом переводилась в ускорения (возможны эффекты весов),
   - тем, что в коде использована конкретная политика отбора точек/галактик.

2) Ненулевое среднее остатков (6%) и медиана ~1.3% говорят, что глобально модель не “вся в плюс/вся в минус”, но есть довольно широкий разброс (std ~0.42).

### 4.2. Внутренняя согласованность отчёта
Есть некоторая “развязка”: сначала заявлено “RSL-MOND работает с одним параметром”, но затем сравнительная таблица говорит, что “простая RSL-интерполяция не работает” и лучшая — MOND‑like. Это не противоречие, если трактовать так:

- “работает” = в принципе MOND‑подобный одно‑параметрический подход описывает SPARC разумно;
- “не работает” = конкретный выбранный RSL‑вид \(\mu=x/(1+x)\) даёт неверную форму и ломает \(a_0\).

Файл именно к этому и приходит в “Обновлённых выводах”. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

---

## 5) Что именно показано про \(\delta(r)\) и “графовую гравитацию”

В документе присутствует блок “RSL‑гравитация: базовый анализ”, где строятся 4 панели:

1) \(\phi(r)\) и ньютоновский фит \(\phi \sim r^{slope}\),
2) \(\delta(r) = (\phi_{RSL}/\phi_{Newton}) - 1\),
3) сила \(F(r)=-d\phi/dr\) и сравнение со степенным законом Ньютона,
4) \(N(r)\) — число вершин на расстоянии \(r\) (“площадь сферы”), с фит‑наклоном и сопоставлением \(r^2\) (3D).  
Фигура сохраняется как `experiment_A_gravity_analysis.png`. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

### 5.1. Почему это важно для A (и где в отчёте пока “разрыв”)
Эксперимент A по смыслу (как вы ранее формулировали) должен связывать:

- микромодель графа \(\Rightarrow\) \(\phi(r)\), \(\delta(r)\),
- \(\delta(r)\Rightarrow\) эффективное ускорение/скорость в галактиках,
- и далее \(\Rightarrow\) SPARC (RAR/кривые вращения).

В файле видно, что:
- часть “SPARC‑подгонка” сделана в MOND‑языке через \(\mu(x)\) и \(a_0\),
- часть “графовая гравитация” построена как отдельный анализ \(\phi(r),\delta(r),F(r),N(r)\).

То есть в текущем виде отчёта это пока **две полу‑линии**, которые нужно соединить:
- либо вывести, какая \(\mu(x)\) эквивалентна вашей \(\delta(r)\) (или наоборот),
- либо показать, что из симулятора графа реально возникает форма, близкая к \(\mu(x)=1-e^{-\sqrt{x}}\).

Ваш собственный вывод “RSL‑теория должна предсказывать \(\mu=1-e^{-\sqrt{x}}\)” — это как раз точка стыковки: теперь задача не “подогнать SPARC”, а **получить именно такую \(\mu\)** из механизма \(\delta(r)\)/переписывания/embedding. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

---

## 6) Что можно считать сильными сторонами результата (строго по файлу)

1) Масштаб данных большой: 171 галактика, тысячи точек. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

2) Есть полноценная статистика по \(a_0\) (гистограмма log10(a0), scatter‑plot \(\chi^2_{\rm red}\) vs \(a_0\)). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

3) Вы не “заставляете” работать выбранную вами форму \(\mu\), а делаете сравнение и честно фиксируете, что:
   - простая \(\mu=x/(1+x)\) даёт плохие \(\chi^2\) и слишком малый \(a_0\),
   - MOND‑like \(\mu\) даёт лучший \(\chi^2\) и \(a_0\approx 1.05\times10^{-10}\). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

4) Введён анализ RAR‑остатков и scatter, с сопоставлением к числу из SPARC‑литературы (~0.13 dex), что является правильным “санитарным” бенчмарком. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

---

## 7) Главные слабые места/риски интерпретации (которые видны прямо из отчёта)

### 7.1. “Хорошие фиты” и абсолютные \(\chi^2_{\rm red}\)
В сводке у вас фигурируют “хорошие фиты 54% при \(\chi^2_{\rm red}<5\)”. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Но в сравнении функций даже “лучшая” даёт \(\chi^2_{\rm red}=43.5\) (если это действительно reduced chi-square по всем точкам RAR/всем галактикам, а не по иной агрегации). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Это нужно прояснить в следующей версии отчёта:
- \(\chi^2_{\rm red}=43.5\) — это “по RAR‑точкам 3367”?
- или это “суммарный” критерий, не нормированный так же, как галактические \(\chi^2_{\rm red}\)?
- или там разные веса/ошибки?

Иначе может сложиться впечатление, что по одной метрике “54% хорошо”, а по другой “всё плохо”, хотя на деле просто разные определения.

### 7.2. Scatter 0.183 dex хуже 0.13 dex
Вы это честно отмечаете. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Если цель Эксперимента A — “конкурировать” с лучшими подгонками MOND/RAR в литературе, нужно:
- воспроизвести их метод учёта систематик (или явно заявить, что это MVP‑уровень, без M/L и т.д.),
- либо показать, что ваша графовая теория предсказывает дополнительные вклады в scatter (тогда 0.18 — не дефект, а предсказание; но это должен быть отдельный аргумент).

### 7.3. Разрыв “граф → \(\delta(r)\)” vs “\(\mu(x)\)”
Сейчас \(\delta(r)\) проанализирована в модельных единицах (hops), а SPARC‑фит сделан через \(\mu(x)\) в физических единицах ускорения. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Чтобы Эксперимент A был “по вашей теории”, а не “мы тоже подогнали MOND”, нужно сделать один из двух мостов:

- **мост 1:** вывести из графовой модели эффективную \(\mu(x)\) и сравнить её форму с \(1-e^{-\sqrt{x}}\);  
- **мост 2:** вывести \(\delta(r)\) → поправку к \(g(r)\) и показать, что это эквивалентно “MOND‑like” с предсказанным \(a_0\).

---

## 8) Что файл уже подсказывает как “следующий технический шаг”

Ваш финальный “Вывод для RSL‑теории” в отчёте фактически задаёт спецификацию для следующего цикла разработки:

- Требуемая интерполяция: \(\mu(x)=1-e^{-\sqrt{x}}\). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

Значит, следующий шаг Эксперимента A (в духе Experiments_v1) — не повторная подгонка SPARC, а:

1) в симуляторе графовой гравитации получить \(\delta(r)\) в такой форме, чтобы при переходе к ускорениям возникала требуемая \(\mu(x)\);
2) либо параметризовать семейство графов/иерархий и показать, что именно **\(\alpha\), иерархия, нормировка** (как вы ранее планировали) управляют переходной областью (где \(g\sim a_0\)) и дают правильную \(\mu\).

---

## 9) Резюме по результату Эксперимента A (как он представлен в файле)

- SPARC‑данные (171 галактика) действительно обработаны, по каждой галактике строятся \(v_{\rm obs}\), \(v_{\rm bar}\), \(v_{\rm fit}\), оценивается \(\chi^2_{\rm red}\), и собирается распределение \(a_0\). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

- “Простая RSL” \(\mu=x/(1+x)\) даёт плохое качество и заниженный \(a_0\sim 2\times10^{-11}\) (примерно в 5 раз меньше MOND). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

- Лучшая из протестированных интерполяций — MOND‑like \(\mu=1-e^{-\sqrt{x}}\) с \(a_0\approx 1.05\times10^{-10}\), что близко к милгромовскому \(1.2\times10^{-10}\) (разница ~12%). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

- Scatter по RAR: 0.183 dex, что хуже, чем ~0.13 dex из SPARC‑публикации (что нужно либо улучшать методологически, либо объяснять как предсказание/ограничение модели). [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

- В отчёте также есть отдельный “графовый” блок с \(\phi(r)\), \(\delta(r)\), \(F(r)\), \(N(r)\), который пока выступает как предварительная проверка поведения графовой гравитации, но ещё не замкнут в прямой вывод \(\mu(x)\) для SPARC. [(experiment_A_sparc.pdf)](/files/0AMOVBI5MuDAw4s70zb7i)

---

Если хотите, могу следующим сообщением:
1) сформулировать “TargetSpec” для Эксперимента A (что именно симулятор должен выдавать, чтобы считаться успешным),  
2) предложить конкретный алгоритм извлечения \(\mu(x)\) из \(\delta(r)\) (или наоборот),  
3) и дать список минимальных репо‑модулей/метрик для автоматического репорта “SPARC fit + graph‑origin justification” (в стиле вашей структуры world→metrics→report).

Ниже — полностью операциональная спецификация **Эксперимента A** в терминах того, что описано в [Experiments_v1.pdf](/files/2OSgJNaaGTQaJ5a6CTSXL) (δ(r) от графовой геометрии) и в стиле “TargetSpec + метрики + pipeline/репо” из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx). Я также привязываю это к факту из вашего отчёта *experiment_A_sparc.pdf* (который вы ранее показывали): лучшая форма \(\mu(x)\) близка к \(\mu(x)=1-e^{-\sqrt{x}}\), а не \(\mu=x/(1+x)\). Это удобно как “shape target”.

---

# 1) TargetSpec для Эксперимента A (SPARC): что симулятор должен выдавать

## 1.1. Проблема “что считать успехом”
Чтобы A был “по вашей теории”, а не “мы снова сделали MOND‑фит”, успех должен иметь 2 слоя:

1) **Phenomenology fit:** модель на барионах предсказывает \(v(r)\) (или \(g_{\text{obs}}(r)\)) в SPARC с качеством не хуже разумного порога.

2) **Graph-origin justification:** из вашей графовой гравитации (решение \(L\phi=\rho\) + конечные размеры/иерархии) возникает **универсальная форма поправки** \(\delta(r)\) и, при переводе в “MOND‑язык”, возникает интерполирующая функция \(\mu(x)\) **одной формы для всех галактик**, с одним глобальным \(a_0\) (или с узким scatter, объяснимым nuisance‑параметрами).

Поэтому TargetSpec должен оценивать **и fit к данным**, и **универсальность / происхождение \(\mu\)**.

---

## 1.2. Формат TargetSpec (как в [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx))
Сделаем классический интерфейс по архиву прогона:

```python
@dataclass
class TargetResult:
    hit: bool
    score: float          # 0..1
    diagnostics: dict

class TargetSpec:
    def evaluate(self, archive) -> TargetResult:
        ...
```

Где `archive` должен содержать:
- идентификатор галактики,
- массивы радиусов `r_i`,
- барионный вклад (в любой форме, но чтобы из него вычислялось \(g_{\rm bar}(r)\)),
- предсказанные моделью \(v_{\rm pred}(r)\) или \(g_{\rm pred}(r)\),
- ошибки SPARC (скорости/ускорения),
- параметры мира: \(\alpha\), размер графа, уровень иерархии, нормировка единиц и т.д.
- а также “graph-origin артефакты”: \(\phi(r)\), \(F(r)\), \(\delta(r)\) (или достаточно \(\delta\) и baseline).

---

## 1.3. Что именно проверяет TargetSpec: метрики и “hit”

### (A) Fit к кривым вращения (основной наблюдаемый слой)
Для галактики \(g\) с точками \(i=1..n_g\):
- наблюдаемая скорость: \(v_{\rm obs,i}\),
- ошибка: \(\sigma_{v,i}\),
- предсказание: \(v_{\rm pred,i}\).

Метрика:
\[
\chi^2_g=\sum_i \left(\frac{v_{\rm obs,i}-v_{\rm pred,i}}{\sigma_{v,i}}\right)^2,
\quad
\chi^2_{\rm red,g}=\frac{\chi^2_g}{n_g-k}
\]
где \(k\) — число подгоняемых nuisance‑параметров на галактику (например M/L, если разрешаете).

Агрегация по всем галактикам:
- медиана \(\tilde{\chi}^2_{\rm red}\),
- доля “хороших” галактик \(f_{\rm good}=\Pr(\chi^2_{\rm red,g}<\tau)\).

**Критерий hit (MVP):**
- \(f_{\rm good} \ge 0.5\) при \(\tau=5\) (порог как в вашем текущем отчёте),
- и/или \(\tilde{\chi}^2_{\rm red} < 5\).

(Порог можно ужесточать позже; важно зафиксировать один раз.)

### (B) Fit к RAR (универсальность на уровне всех точек)
Определяем:
\[
g_{\rm obs}(r)=\frac{v^2_{\rm obs}(r)}{r},\qquad g_{\rm pred}(r)=\frac{v^2_{\rm pred}(r)}{r}
\]
Считаем scatter:
\[
\sigma_{\rm RAR} = std\left(\log_{10}\frac{g_{\rm obs}}{g_{\rm pred}}\right)
\]
**Hit (MVP):**
- \(\sigma_{\rm RAR} \le 0.20\) dex (как минимум не хуже вашего текущего 0.183 dex),
- и улучшение относительно чисто ньютоновских барионов на заметную величину.

### (C) Graph-origin: “универсальная \(\delta(r)\)” и вывод \(\mu(x)\)
Нужна метрика, что **\(\mu\) получается одной формы** при склейке всех галактик.

Предлагаю 2 диагностических условия:

1) **Shape match:** извлечённая \(\mu_{\rm implied}(x)\) близка к целевому шаблону \(\mu_{\rm template}(x)\) (например, \(1-e^{-\sqrt{x}}\)) по интегральной ошибке на лог‑сетке \(x\):
\[
E_\mu = \int_{\log x_{\min}}^{\log x_{\max}}
\left|\mu_{\rm implied}(x)-\mu_{\rm template}(x)\right|\,d\log x
\]
Hit: \(E_\mu < \epsilon_\mu\) (например 0.05–0.1; зависит от шума).

2) **Single global \(a_0\):** при обратном выводе \(a_0\) из точек получается узкий разброс:
- медиана \(a_0\) в допустимом диапазоне,
- относительный scatter \(std(\log a_0)\) меньше порога (например <0.25 dex).

---

## 1.4. Итоговый score (0..1) и hit
Чтобы было похоже на “мульти‑объектив” из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx), можно объединить:

- \(S_{\rm rot}\) — нормированная метрика качества вращательных кривых,
- \(S_{\rm rar}\) — нормированная метрика scatter,
- \(S_{\mu}\) — метрика shape match.

Например:
\[
score = 0.5 S_{\rm rot} + 0.3 S_{\rm rar} + 0.2 S_{\mu}
\]
`hit=True`, если:
- \(f_{\rm good}\ge 0.5\) **и**
- \(\sigma_{\rm RAR}\le 0.20\) dex **и**
- \(E_\mu \le \epsilon_\mu\).

---

# 2) Конкретный алгоритм извлечения \(\mu(x)\) из \(\delta(r)\) (и обратный)

Здесь важно: \(\delta(r)\) в вашем A — это поправка к ньютоновскому закону, возникающая из графа. Чтобы связать её с MOND‑формализмом, надо строго определить, что такое “baseline” и что такое “effective”.

## 2.1. Определения (минимальные, но достаточные)
Пусть для заданного барионного распределения вы можете получить:

- \(g_N(r)\) — ньютоновское (барионное) ускорение (из SPARC или из вашего же вычисления на “идеальном 3D”/континууме),
- \(g_{\rm eff}(r)\) — ускорение из графовой модели (через \(L\phi=\rho\) и дискретный градиент).

Тогда естественное определение:
\[
g_{\rm eff}(r)=g_N(r)\,(1+\delta(r))
\]
где
\[
\delta(r)=\frac{g_{\rm eff}(r)}{g_N(r)}-1
\]

### Как получить \(g_{\rm eff}\) из графа
Если у вас поле \(\phi\) на узлах и есть embedding в 3D, то на радиальном профиле:
- строите \(\phi(r)\) усреднением по оболочкам,
- затем \(g_{\rm eff}(r)=\left|\frac{d\phi}{dr}\right|\) (численно по сетке r).

(Если embedding нет — используйте hop‑радиус, но тогда нужно калибровать r→hops; это отдельный модуль “units”.)

---

## 2.2. Из \(\delta(r)\) → \(\mu(x)\) (прямая задача)
В MOND (в “μ‑форме”) связь обычно пишут как:
\[
g_N = \mu\!\left(\frac{g}{a_0}\right)\,g
\]
где \(g\) — наблюдаемое/эффективное ускорение.

У нас \(g=g_{\rm eff}\). Тогда:
\[
\mu(x)=\frac{g_N}{g_{\rm eff}}
\quad \text{при}\quad x=\frac{g_{\rm eff}}{a_0}
\]

Но \(a_0\) может быть:
- либо фиксирован глобально (если вы уже выбрали калибровку),
- либо извлечён из данных (см. ниже).

Если подставить связь через \(\delta\):
\[
\mu = \frac{1}{1+\delta(r)}
\]

**Алгоритм (практически):**
1) Для множества радиальных точек \(r_i\) (по многим галактикам) вычислить:
   - \(g_{N,i}\),
   - \(g_{{\rm eff},i}\),
   - \(\mu_i = g_{N,i}/g_{{\rm eff},i} = 1/(1+\delta_i)\).
2) Если \(a_0\) фиксирован: поставить \(x_i=g_{{\rm eff},i}/a_0\) и построить \(\mu(x)\) как облако + сглаживание/бинирование.
3) Если \(a_0\) не фиксирован: оценить \(a_0\) (см. 2.4), затем сделать пункт 2.

**Что ожидаете увидеть**, если ваша графовая теория эквивалентна MOND‑like интерполяции:
- облако \((x_i,\mu_i)\) ложится на одну кривую (малый scatter),
- форма близка к \(\mu(x)=1-e^{-\sqrt{x}}\) (как вы получили в спарк‑отчёте).

---

## 2.3. Из \(\mu(x)\) → \(\delta(r)\) (обратная задача)
Если вы хотите стартовать от “эмпирической” \(\mu\) и понять, какая \(\delta\) ей соответствует:

Из \(\mu = g_N/g\):
\[
\frac{g}{g_N} = \frac{1}{\mu(x)}
\Rightarrow
1+\delta = \frac{1}{\mu(x)}
\Rightarrow
\delta = \frac{1}{\mu(x)}-1
\]

Здесь \(x=g/a_0\). Чтобы выразить \(\delta\) в функции \(r\), используете \(g=g(r)\), \(g_N=g_N(r)\).
На практике:
- берёте радиальную точку,
- вычисляете \(g_N(r)\),
- решаете уравнение \(g_N=\mu(g/a_0)\,g\) относительно \(g\) (обычно численно),
- получаете \(\delta(r)=g/g_N-1\).

Это нужно, если вы хотите проверить: “похожа ли \(\delta(r)\) из графа на \(\delta(r)\), имплицированную лучшей \(\mu\)”.

---

## 2.4. Как извлечь \(a_0\) “из \(\delta\)” без отдельного MOND‑фита
Чтобы не “подгонять MOND поверх графа”, можно определить \(a_0\) как масштаб, при котором кривая \(\mu(x)\) из графа наиболее “склеивается” в одну универсальную:

**Оптимизация \(a_0\) как collapse‑параметра:**
1) Для кандидата \(a_0\) вычислить \(x_i=g_{{\rm eff},i}/a_0\), \(\mu_i=g_{N,i}/g_{{\rm eff},i}\).
2) Бинировать по \(\log x\) и посчитать дисперсию \(\mu\) внутри бинов.
3) Выбрать \(a_0\), минимизирующий сумму внутрибиновых дисперсий:
\[
J(a_0)=\sum_{b} Var(\{\mu_i: i\in b\})
\]

Это очень полезно: \(a_0\) становится “структурным масштабом” вашей геометрии (нормировка/finite size), а не параметром эмпирического закона.

---

# 3) Минимальные репо‑модули и метрики для авто‑репорта “SPARC fit + graph-origin justification”

Ниже — минимальный скелет, который соответствует стилю “data ingestion → simulation → fit → report” из [Experiments_v1.pdf](/files/2OSgJNaaGTQaJ5a6CTSXL) и интерфейсам TargetSpec из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx).

## 3.1. Структура репозитория
```
repo/
  README.md
  pyproject.toml

  data/
    sparc_raw/                 # оригинальные файлы SPARC
    sparc_processed/           # кэш numpy/parquet

  world/
    graph_generator.py         # power-law graph (alpha, hierarchy, size)
    laplacian.py               # L construction, solvers, BC handling
    gravity_solver.py          # solve L phi = rho
    embedding.py               # IFACE embedding + distance/r shells
    units.py                   # hops <-> kpc, phi-scale, G_eff mapping

  models/
    baryons.py                 # rho(r) from SPARC components (gas/disk/bulge)
    forward.py                 # from phi -> g_eff(r) -> v_pred(r)
    delta.py                   # delta(r) computation helpers

  sparc/
    ingest.py                  # load SPARC, validate, compute g_bar, v_bar, etc.
    galaxy_selection.py        # cuts, masks, inclination cuts, quality flags

  fit/
    nuisance.py                # M/L handling (optional), distance scaling
    global_params.py           # fit alpha/hierarchy/norm (global)
    collapse_a0.py             # compute a0 by variance-collapse (2.4)
    baseline_models.py         # Newton-only, optional MOND baseline

  targets/
    target_spec_A.py           # TargetSpecRotation, TargetSpecRAR, TargetSpecMu
    scoring.py                 # combine metrics -> score/hit

  metrics/
    rotation.py                # chi2 per galaxy, f_good, residual plots
    rar.py                     # scatter dex, residual stats
    mu_extraction.py           # mu(x) from delta, shape-fit to template
    universality.py            # cross-galaxy collapse metrics

  reports/
    make_report.py             # renders md/html/pdf
    figures.py                 # all plots: v(r), RAR, mu(x), delta(r), etc.
    templates/

  experiments/
    run_A_pipeline.py          # end-to-end: ingest -> sim -> fit -> report
    configs/
      A_default.yaml
      A_sweep_alpha.yaml

  tests/
    test_units.py
    test_laplacian_solver.py
    test_mu_delta_consistency.py
    test_reproducibility_hash.py
```

## 3.2. Какие артефакты обязателен авто‑репорт
**Отчёт должен генерироваться одной командой** (например `python -m experiments.run_A_pipeline --config ...`) и включать:

1) **SPARC summary**
- сколько галактик/точек,
- какие cuts.

2) **Rotation curve fit**
- распределение \(\chi^2_{\rm red}\),
- топ‑N showcase галактик: \(v_{\rm obs}, v_{\rm bar}, v_{\rm pred}\).

3) **RAR**
- scatter (dex),
- residual plots.

4) **Graph-origin section**
- пример(ы) \(\phi(r)\), \(g_{\rm eff}(r)\), \(\delta(r)\),
- глобальная \(\mu(x)\), извлечённая из \(\delta\),
- сравнение \(\mu\) с шаблоном (например \(1-e^{-\sqrt{x}}\)) + численная ошибка \(E_\mu\),
- найденный “collapse \(a_0\)” и его стабильность по подвыборкам.

5) **Reproducibility**
- хэши конфигов/версии мира (как вы хотите в [Experiments_v1.pdf](/files/2OSgJNaaGTQaJ5a6CTSXL)),
- seed’ы, версии зависимостей.

---

## 3.3. Минимальный набор метрик (в коде)
- `metrics.rotation.chi2_per_galaxy()`
- `metrics.rotation.f_good(threshold=5)`
- `metrics.rar.scatter_dex()`
- `metrics.mu_extraction.mu_points_from_delta()`
- `metrics.mu_extraction.fit_template_mu()` → \(E_\mu\)
- `fit.collapse_a0.find_a0_collapse()` → \(a_0\) без MOND‑фита
- `metrics.universality.collapse_score()` (внутрибиновая дисперсия)

---

# 4) Практическая “точка сборки”: как выглядит pipeline в одном абзаце
1) `sparc/ingest.py` читает SPARC и формирует для каждой галактики барионный профиль \(\rho(r)\) / \(v_{\rm bar}(r)\).  
2) `world/graph_generator.py` создаёт семейство графов (глобальные \(\alpha\), иерархия).  
3) `world/gravity_solver.py` решает \(L\phi=\rho\) и через `models/forward.py` получает \(g_{\rm eff}(r)\), \(v_{\rm pred}(r)\), \(\delta(r)\).  
4) `metrics/rotation.py` и `metrics/rar.py` оценивают качество по данным.  
5) `metrics/mu_extraction.py` строит \(\mu(x)=1/(1+\delta)\), `fit/collapse_a0.py` выбирает \(a_0\) по “collapse”.  
6) `targets/target_spec_A.py` решает `hit/score`, а `reports/make_report.py` печатает полный отчёт.

---

Если вы ответите, какой именно объект у вас сейчас является “графовой дистанцией” (hops / embedding L2 / спектральная), я уточню самый чувствительный кусок для A: как из \(\phi\) корректно извлекать радиальный профиль \(g_{\rm eff}(r)\) так, чтобы \(\delta(r)\) не зависела от произвольного биннинга. Также могу предложить минимальную схему калибровки единиц (hops→kpc) через один фиксированный “матчинг” к SPARC, не превращая это в скрытый фит.

### 1) Как корректно извлекать радиальный профиль \(g_{\mathrm{eff}}(r)\) на графе (метрика = hops) так, чтобы \(\delta(r)\) не зависела от биннинга

Проблема биннинга возникает, когда вы делаете “сферические оболочки” по целочисленному \(r=\) hops и усредняете \(\phi\) по вершинам на данном расстоянии. В power‑law графах “сфера” \(S_r=\{v: d(v,s)=r\}\) имеет шум (дискретность, неоднородность степени), и простое среднее \(\langle \phi\rangle_{S_r}\) + конечная разность создаёт зависимость от того, как вы сгладили.

Ниже — два способа, которые **устраняют произвольность биннинга**: один “локальный” (через поток/градиент на рёбрах), другой “вариационный” (через энергию Дирихле). Оба определяются на графе естественно и не требуют выбора ширины бина.

---

## 1.1. Метод A (рекомендую как основной): “радиальная сила” как поток через графовую сферу

Если \(\phi\) решает дискретное уравнение Пуассона \(L\phi=\rho\), то естественный аналог гравитационного поля на ребре \((u,v)\):

\[
E_{uv} = \phi(u)-\phi(v)
\]

(взвешенный вариант: \(E_{uv}=w_{uv}(\phi(u)-\phi(v))\), если у вас веса рёбер).

Тогда “радиальное” поле на расстоянии \(r\) от источника \(s\) можно определить как **средний направленный поток** через границу шара:

- слой: \(S_r=\{u: d(s,u)=r\}\)
- следующий слой: \(S_{r+1}=\{v: d(s,v)=r+1\}\)
- граница (множество рёбер) между слоями:
\[
\partial B_r = \{(u,v): u\in S_r,\ v\in S_{r+1}\}
\]

Определяем суммарный поток:
\[
\Phi_E(r) = \sum_{(u,v)\in \partial B_r} w_{uv}\,(\phi(u)-\phi(v))
\]

И нормируем на “площадь” границы (число/сумму весов пересекающих рёбер):
\[
A(r) = \sum_{(u,v)\in \partial B_r} w_{uv}
\]

Тогда определение радиального ускорения (в hops‑единицах):
\[
g_{\mathrm{eff}}(r) = \frac{\Phi_E(r)}{A(r)}
\]

Почему это хорошо:
- вообще **не нужен** выбор “толщины оболочки” — вы используете естественную границу между уровнями BFS;
- это аналог “\(g = -\partial_r\phi\)” но в виде **потока через поверхность**, который на дискретных структурах устойчивее;
- если граф “почти изотропен” в среднем, то это очень близко к классическому радиальному полю.

Практическая деталь: знак. Для гравитации обычно \(g>0\) как модуль ускорения к центру. Тогда берите:
```python
g_eff[r] = - Phi_E(r) / A(r)
```
или модуль.

**Диагностика из того же расчёта:** вы одновременно получаете \(A(r)\) и можете строить \(N(r)=|S_r|\) и “эффективную размерность поверхности”:
\[
A(r)\propto r^{D_{\mathrm{surf}}-1}
\]
что напрямую связывает \(\delta(r)\) с “геометрией графа” (как в [Experiments_v1.pdf](/files/2OSgJNaaGTQaJ5a6CTSXL)).

---

## 1.2. Метод B (альтернатива): “радиальное ускорение” из энергии Дирихле в кольце

Определим энергию (дискретный аналог \(\int |\nabla\phi|^2\)):
\[
\mathcal{E}(R)=\sum_{(u,v): u\in B_R,\ v\notin B_R} w_{uv}\,(\phi(u)-\phi(v))^2
\]

Тогда “средний градиент” на границе масштаба \(R\) оценивается как:
\[
g_{\mathrm{eff}}(R) \approx \sqrt{\frac{\mathcal{E}(R)}{A(R)}}
\]

Плюсы:
- ещё менее чувствителен к локальным флуктуациям \(\phi\),
- даёт устойчивый “модуль поля”.

Минусы:
- вы теряете знак и получаете “RMS‑ускорение”, но для \(\delta(r)\) обычно достаточно модуля.

---

## 1.3. Как получать \(\delta(r)\) без биннинга
Если базовый ньютоновский закон вы формулируете как \(g_N(r)\propto 1/r^2\) в hops‑координате, то:
\[
\delta(r)=\frac{g_{\mathrm{eff}}(r)}{g_N(r)}-1
\]

Важно: \(g_N\) нужно строить **в той же** hops‑метрике, иначе вы смешаете геометрию и калибровку. Минимально корректный вариант (без “внутреннего фита”):
- берёте “окно ньютоновского скейлинга” \([R_{\min},R_{\max}]\) как в вашем отчёте [experiment_A_sparc.pdf](/files/0AMOVBI5MuDAw4s70zb7i),
- оцениваете степенной закон \(g_{\mathrm{eff}}\sim r^{p}\) и проверяете \(p\approx-2\) там (это у вас уже делается),
- определяете \(g_N(r)=C\cdot r^{-2}\) с \(C\) взятым **не фиттом под галактики**, а из **единственной калибровки** (см. ниже про hops→kpc и масштаб).

Если вы всё же хотите “внутренний” \(C\) на уровне одного мира/графа (не галактики), можно взять:
\[
C = \mathrm{median}_{r\in [R_{\min},R_{\max}]}\bigl(g_{\mathrm{eff}}(r)\,r^{2}\bigr)
\]
Это не “скрытый фит к SPARC”, потому что это калибровка **внутри** симулятора на его ньютоновском окне.

---

## 1.4. Минимальная реализация (скелет)
В терминах вашего мира с hops:

```python
def shells_bfs(graph, source):
    # returns dist[v] and shells: list of lists S_r
    ...

def boundary_edges(graph, shells, r):
    # edges between S_r and S_{r+1}
    ...

def g_eff_flux(phi, graph, shells, r):
    edges = boundary_edges(graph, shells, r)
    Phi = 0.0
    A = 0.0
    for u,v,w in edges:  # w=1 if unweighted
        Phi += w * (phi[u] - phi[v])
        A   += w
    if A == 0: return np.nan
    return -Phi / A, A

# produce g_eff[r], A[r] for r=1..Rmax-1
```

Это даёт вам \(g_{\mathrm{eff}}(r)\) и “площадь” \(A(r)\) без какого-либо сглаживания/биннинга по \(\phi\).

---

# 2) Минимальная схема калибровки единиц (hops → kpc) “одним матчингом”, без скрытого фита к SPARC

Здесь важный нюанс: если вы позволите себе подбирать mapping hops→kpc *для каждой галактики*, вы действительно спрячете гало/подгонку в единицах. Поэтому схема должна быть:

- **одна глобальная константа** \(\kappa\) (kpc per hop) для всех прогонов/галактик,
- полученная из **одного** “якорного соответствия” (и затем фиксируется),
- и все остальные сравнения делаются без изменения \(\kappa\).

Ниже две минимальные схемы, выбирайте одну.

---

## 2.1. Схема 1 (рекомендую): якорь по “переходу” \(a_0\) / RAR‑масштабу (1 число)
SPARC/RAR задаёт характерный ускорительный масштаб \(a_0\approx 1.2\times 10^{-10}\,\mathrm{m/s^2}\). В вашем MOND‑языке из графа он возникает как масштаб, где \(\delta\) начинает отклоняться от 0 (конец ньютоновского окна).

Идея: в симуляторе вы можете определить “внутренний” hop‑масштаб \(R_*\), где начинается систематическое отклонение:

**Определение \(R_*\) (без биннинга):**
- находите минимальный \(r\), где \(|\delta(r)|>\delta_{\rm thr}\) и держится так на окне ширины \(W\) (чтобы не ловить шум).

Тогда вы говорите: “этот \(R_*\) соответствует типичному радиусу, где \(g_{\rm bar}\sim a_0\) в реальных дисках”.

Чтобы не делать фит “под типичную галактику”, берёте **один фиксированный эталон** из SPARC:
- например, Млечный Путь не годится (нет в SPARC как стандартный объект), но можно взять одну “калибровочную” галактику с хорошими данными и средним масштабом (выбирается один раз и фиксируется в репо как `CALIB_GALAXY_ID`).
- определяете у неё радиус \(r_{\rm SPARC,*}\), где \(g_{\rm bar}(r)\) пересекает \(a_0\) (по данным барионов).

Тогда:
\[
\kappa = \frac{r_{\rm SPARC,*}\;(\mathrm{kpc})}{R_*\;(\mathrm{hop})}
\]

И всё. Это один матчинг, не “скрытый фит по всем”.

Плюс: это концептуально соответствует вашему “окну скейлинга” из [Experiments_v1.pdf](/files/2OSgJNaaGTQaJ5a6CTSXL).

---

## 2.2. Схема 2: якорь по “ньютоновскому окну” (геометрия) и одному физическому масштабу
Если вы не хотите использовать \(a_0\), можно сделать чисто геометрический якорь:

1) В симуляторе определяете hops‑диапазон \([R_{\min},R_{\max}]\), где закон \(g\sim r^{-2}\) выполняется с \(R^2>0.9\) (у вас это уже тест совместимости, см. [ftl_physics(3).pdf](/files/RiFu_bq20Eu_J2UvoOaVf)).
2) В SPARC выбираете один фиксированный эталон (одна галактика) и говорите: её радиальный диапазон \([r_{\min},r_{\max}]\), где доминируют барионы и виден ньютоновский спад (определяется по данным/качеству), соответствует вашему окну.

Тогда:
\[
\kappa = \frac{r_{\max}-r_{\min}}{R_{\max}-R_{\min}}
\]
или по медиане отношений на нескольких точках внутри окна (но **внутри одной** калибровочной галактики).

Это хуже физически (меньше смысла), но минимально и не превращается в глобальную подгонку.

---

## 2.3. Важно: разделить “единицы расстояния” и “единицы ускорения”
Даже если вы закрепили \(\kappa\) (kpc/hop), вам ещё нужен коэффициент перевода “графового ускорения” в \(\mathrm{(km/s)^2/kpc}\) или \(\mathrm{m/s^2}\). Чтобы не устроить скрытый фит:

- фиксируйте **один** глобальный коэффициент \(\gamma\) (ускорение на 1 hop‑градиент \(\phi\)) один раз, опять же через один якорь.

Пример: после выбора \(\kappa\), используйте тот же эталон, в одном радиусе \(r_0\) внутри ньютоновского окна, и матчите \(g_{\mathrm{eff}}(R_0)\) к \(g_{\rm bar}(r_0)\) (который известен из SPARC). Это один скаляр \(\gamma\).

Дальше вы не имеете права менять \(\kappa,\gamma\) для других галактик.

---

# 3) Что это даёт для δ(r) и “универсальности”
После перехода на потоковое определение \(g_{\mathrm{eff}}(r)\) и фиксации \(\kappa,\gamma\):

- \(\delta(r)\) становится **стабильной функцией** масштаба в hops (и переносимой в kpc),
- форма \(\delta(r)\) перестаёт быть артефактом того, как вы усредняли \(\phi\) по оболочкам,
- а “универсальность” проверяется честно: одна и та же \(\delta(r)\) (после масштабирования) объясняет множество кривых.

---

Если хотите, я могу написать точные сигнатуры функций/классов (в стиле вашего `world.core.world.World`) для:
- `RadialProfileExtractor(graph, source).g_eff_flux(phi)`
- `UnitCalibrator.fit_once(calib_galaxy_id)`
и показать, какие именно поля сохранять в `archive` для TargetSpec A (чтобы репорт полностью воспроизводился).

Если базовые правила мира **обратимы**, то в смысле динамических систем у вас действительно появляется корректное понятие “обратного течения”: существует отображение шага \(F\) и обратное \(F^{-1}\), и любая траектория \(S_0 \to S_1 \to \dots\) может быть пройдена назад. Но это **не означает автоматически “машину времени”** в физическом смысле (с передачей полезной информации в прошлое и парадоксами). Ниже — разбор по двум вашим вариантам и что это требует в рамках ваших же ограничений (контекст=0 vs device‑режим, детерминизм из [Probability_v1(1).pdf](/files/J1N6bqK2Nj0uLmkcJqCG6), и “операциональные тесты” из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx)).

---

## 1) “Физический откат всей системы назад” (глобальный time‑reversal)

### 1.1. Что означает “возможно” формально
Если ваш мир — это обратимая переписывающая система (пермутация состояний), то:

- для любого состояния \(S_t\) существует **единственный предок** \(S_{t-1}=F^{-1}(S_t)\);
- “откат” — это не перемещение в прошлое, а **запуск эволюции по \(F^{-1}\)**.

Это похоже на классическое time‑reversal в микрофизике: законы обратимы, но макро‑“стрела времени” возникает статистически.

### 1.2. Почему это не даёт “практическую” машину времени
Чтобы “вернуться назад” физически, нужно не просто существование \(F^{-1}\), а возможность **реализовать** его как допустимое действие/режим мира.

В вашей терминологии из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx):
- в **baseline (context=0)** вы, скорее всего, не хотите разрешать action, который глобально переключает динамику на \(F^{-1}\), потому что это ломает совместимость со “стрелой времени” и наблюдаемой термодинамикой;
- в **device‑режиме** теоретически можно сделать “ActionTimeReverse” или “ActionWorldRollback”, но тогда это должно проходить тот же контроль совместимости/штрафов (causality, paradox rate, β₁_sem и т.п.).

### 1.3. Операциональный критерий: это “time travel” или просто обратимый симулятор
Физический смысл появляется только если существует наблюдаемый эффект вида:
- система возвращается в макросостояния, которые ранее были в истории,
- при этом наблюдатель **сохраняет некоторую информацию** об “прошлой” ветке.

Если же при откате всё состояние, включая память наблюдателя, откатывается строго детерминированно, то с точки зрения внутреннего наблюдателя **ничего не произошло**: он не может зафиксировать факт отката, потому что его записи, мозг, артефакты — тоже откатились.

И тогда это не “машина времени”, а просто свойство обратимости динамики “снаружи”.

---

## 2) “Откат назад только сознания/наблюдателя без физического перемещения”

Это существенно более тонко и, строго говоря, **несовместимо** с полной детерминированностью в смысле [Probability_v1(1).pdf](/files/J1N6bqK2Nj0uLmkcJqCG6), если понимать “сознание” как часть полного состояния мира.

### 2.1. Если наблюдатель — часть полного состояния \(S\)
В вашем модальном принципе детерминизма:

- одно и то же полное состояние \(S(t)\) допускает ровно одно продолжение.

Если “сознание/память” — компонент \(S\), то “откатить только сознание” означает:
- либо изменить компонент памяти, не изменяя остальной мир,
- либо сделать так, что при одном и том же физическом \(S_{\text{world}}\) возможны разные \(S_{\text{obs}}\).

Оба варианта выглядят как:
- **вмешательство внешнего агента** (action, меняющий часть состояния),
- или **недоопределённость полного состояния** (т.е. вы не включили “память” в \(S\), и тогда детерминизм формально нарушается лишь из‑за неполноты описания).

Так что “откат сознания без мира” возможен только если вы явно вводите:
- device‑action, который перезаписывает состояние IFACE/OBS (память, контекст, λ_s(t), Q(t)), или
- разделение “онтологического мира” и “эпистемического интерфейса”, где IFACE может менять свою внутреннюю репрезентацию без изменения внешнего мира.

### 2.2. Чем это будет похоже на реальные эффекты
Это будет выглядеть не как путешествие во времени, а как:
- **амнезия / перезапись памяти** (observer memory reset),
- или **смена контекста восприятия** (IFACE re-mapping), при которой один и тот же мир интерпретируется иначе.

Чтобы это было “петля во времени” для наблюдателя, нужно дополнительно:
- чтобы внешний мир оказался в состоянии, которое ранее было (или выглядело как “ранее было”), при том что наблюдатель сохранил память.  
Но это уже требует либо глобального rollback мира, либо скрытого “буфера истории” (что обычно эквивалентно хранению прошлого состояния где-то ещё).

---

## 3) Парадоксы и почему они не обязаны появляться даже при обратимости

Парадокс типа “убить дедушку” появляется, когда:
1) можно передать **свободную информацию** в прошлое,
2) и эта информация может изменить то прошлое так, что она сама не будет послана.

В детерминированной обратимой системе можно избежать парадоксов двумя стандартными способами (и они хорошо ложатся на вашу архитектуру):

### 3.1. Жёсткий запрет “сигналов в baseline”
В baseline (context=0) вы просто не разрешаете actions, которые реализуют \(F^{-1}\) или wormhole‑связи, нарушающие локальную причинность.

### 3.2. Novikov‑подобная самосогласованность в device‑режиме
Если вы разрешаете “петли”, то допускаете только такие траектории, которые **самосогласованы** (фиксированная точка глобальной истории). Тогда “парадоксальные” действия просто не реализуются: не потому что “магия”, а потому что в детерминированной системе нет альтернативной ветки.

Это напрямую согласуется с вашим принципом “невозможности ветвления” из [Probability_v1(1).pdf](/files/J1N6bqK2Nj0uLmkcJqCG6): при полном состоянии нет двух будущих.

---

## 4) Что бы я предложил как строгие тесты (если вы хотите включить это как эксперимент)

1) **Test TR‑1 (Reversibility check):** показать, что \(F^{-1}(F(S))=S\) на большом наборе случайных состояний (state hash, как вы делали в C).

2) **Test TR‑2 (Global rollback observability):**
   - выполнить \(k\) шагов вперёд, сохранить внешний “лог” (вне мира, в репо),
   - выполнить \(k\) шагов назад,
   - снова \(k\) шагов вперёд,
   - проверить, что мир вернулся в идентичную траекторию (hash совпадает).
   Это докажет обратимость “снаружи”.

3) **Test TR‑3 (Observer-only reset):**
   - определить, какие компоненты state относятся к IFACE/OBS,
   - сделать action, меняющий только их,
   - проверить, что мир‑физика (граф, \(\phi\), инварианты) неизменна, но метрики восприятия (λ, Ξ, t_OT) меняются.
   Это будет “перезапись наблюдателя”, а не time travel — и это важно честно так назвать.

---

### Итог
- **Глобальный откат мира** возможен на уровне математики, если правила обратимы, но “машина времени” появляется только если вы разрешите соответствующий action и покажете операционально наблюдаемые последствия (обычно это ломает baseline‑совместимость и должно быть device‑режимом).
- **Откат только сознания** в детерминированной онтологии — это либо внешнее вмешательство (action на IFACE), либо признак, что “сознание” не включено в полное состояние \(S\). Внутренне это будет выглядеть как reset/ремаппинг интерфейса, а не буквальный возврат мира в прошлое.

Если вы скажете, как у вас сейчас устроен state (что именно входит в \(S\): граф, \(\phi\), переписывание, OBS/IFACE память, лог событий), я предложу конкретную спецификацию “ActionRollback” и набор CI‑тестов, которые отделяют: (а) математическую обратимость, (б) физическую наблюдаемость отката, (в) observer‑only reset.

Вы правы: при **обратимых правилах** “обратное течение” в принципе допустимо. Но из того, что шаг эволюции обратим, **не следует автоматически**, что внутри мира реализуема “машина времени” в смысле *наблюдаемого возврата в прошлое с сохранением памяти* или *переписывания прошлого*. В вашей архитектуре (по описанию состояния \(S\)) как раз видно, где “стрела времени” может появляться даже при микроскопической обратимости, и какие именно варианты реально операционализуемы.

Ниже разложу оба ваших сценария, но привяжу к вашей структуре состояния:

\[
S(t)=\{s(t), \phi(t), graph, RuleSet, IFACEState(t), IFACEHistory, SemanticState\}
\]

и к тому, что **history/semantics** — это уже “память наблюдателя” (а значит часть полного состояния, если вы считаете мир закрытым).

---

## 1) Вариант А: физический откат всей системы назад (global rollback)

### 1.1. Формально это возможно
Если `EvolutionEngine.step()` реализует биекцию на микросостояниях (или на расширенном состоянии), то существует обратный шаг \(F^{-1}\). Тогда траектория:

\[
S_0 \to S_1 \to \dots \to S_T
\]

может быть пройдена назад:

\[
S_T \to S_{T-1} \to \dots \to S_0
\]

Это не “философия”; это чистая математика обратимой динамики.

### 1.2. Но это не “машина времени” для внутреннего наблюдателя, если память тоже откатывается
Ключевой момент в вашей структуре: у вас есть **IFACEHistory** и **SemanticState**, которые хранят “память”/выученные законы.

Если вы делаете глобальный rollback честно, то откатываются:
- `s`, `phi`, `t`,
- состояния IFACE на каждом шаге,
- **и** `IFACEHistory` (т.е. память о том, что происходило),
- **и** `SemanticState` (если он изменяется во времени).

Тогда внутренний наблюдатель не может зафиксировать, что “время шло назад”: после возврата в \(S_{t}\) он **тождественно** окажется в прежнем состоянии, включая память. Это похоже на идеальную обратимость микрофизики: “снаружи” мы можем прокрутить плёнку назад, но “внутри плёнки” никто не заметит.

### 1.3. Когда это станет “машиной времени” наблюдаемо
Только если существует **неоткатываемый след** (“external ledger”), который не входит в \(S\). Например:
- запись логов вне симуляции,
- или внешний наблюдатель уровня “мета-мир”.

Либо если внутри мира есть подсистема, которая **не откатывается** при rollback (что уже нарушает “откат всей системы”).

---

## 2) Вариант B: откат назад только сознания/наблюдателя без физического отката мира

### 2.1. Если сознание/память — часть полного S, то “откатить только сознание” означает нарушить обратимость/детерминизм или добавить внешнее действие
В вашем описании память наблюдателя — это:
- `IFACEHistory` (временной ряд),
- `SemanticState` (выученные законы),
- частично `_prev_objects` и прочие кэши.

Если вы “откатываете” только эту часть, не меняя `s, phi, graph`, то вы делаете операцию вида:

\[
S = (W, O) \mapsto (W, O')
\]

где \(W\) — физический мир, \(O\) — наблюдатель.

Это **не** естественное следствие обратимости \(F\). Это отдельный оператор (action), который:
- либо не обратим,
- либо обратим, но тогда вы должны сохранять где-то исходный \(O\), т.е. опять нужен буфер.

То есть “observer-only time travel” в строгом смысле — это не путешествие во времени, а **перезапись/ресет наблюдательской подсистемы**.

### 2.2. Как это будет выглядеть феноменологически
Внутри симуляции это проявится как:
- амнезия,
- “перезапуск интерпретации” (смена контекста/семантики),
- возможное изменение поведения в device-mode, если триггеры завязаны на λ/Ξ/OT (как вы делали в C).

Это не даёт “отправки информации в прошлое”. Это даёт “удаление информации в настоящем”.

### 2.3. Единственный способ получить “я помню будущее, но я в прошлом” — это вынести память за пределы откатываемой системы
Если хотите сценарий “я вернулся в прошлое и помню то, что было”, то память должна находиться:
- либо в мета-уровне (вне \(S\)),
- либо в степени свободы, которая не входит в rollback-операцию (что противоречит “откат всей системы”).

Внутри замкнутого детерминированного обратимого мира такое невозможно: “память о будущем” — это информация, которая должна быть закодирована в текущем состоянии; а если вы реально вернулись в прошлое состояние, там этой информации нет.

---

## 3) Что в вашей текущей архитектуре реально сделать “на уровне эксперимента”
Вы можете превратить это в строгий вопрос (в стиле A/B/C/D: таблицы, manifest, target-spec) и тем самым снять философичность:

### 3.1. Эксперимент TR‑A: проверка обратимости ядра
- состояние “микро”: `s, phi, t` (+ всё, что участвует в step)
- проверка: \(F^{-1}(F(S)) = S\) (по hash состояния)
- если не выполняется — правила не полностью обратимы на реализованном уровне (часто из-за “скрытых” кэшей или неоднозначного выбора места применения правила).

### 3.2. Эксперимент TR‑B: “глобальный rollback” и наблюдаемость
- запустить T шагов вперёд,
- сделать rollback на T шагов,
- снова вперёд на T,
- сравнить **полный state hash** с первоначальной траекторией.
Это докажет, что rollback реальный, а не “похожий”.

### 3.3. Эксперимент TR‑C: observer-reset как отдельный action (не time travel)
- определить, какие поля относятся к “observer memory”: `IFACEHistory`, `SemanticState`, `_prev_objects`
- применить “reset observer” без изменения `s, phi, graph`
- проверить: физические инварианты сохраняются, а семантические/исторические меняются.
Это будет корректная, воспроизводимая формализация вашего варианта “откат сознания”.

---

## 4) Почему “парадоксы” не обязаны появляться даже при откатах
Парадоксы возникают только если:
- есть возможность переносить информацию в прошлое **при сохранении её в будущем** (т.е. две несовместимые записи мира).

В детерминированной обратимой системе без внешней памяти этого не происходит: допускаются только самосогласованные траектории. Любая “петля” (если вы её разрешите) будет фиксированной точкой эволюции, а не ветвлением.

---

## Практический вывод по вашему вопросу
1) **Физический откат всей системы** возможен математически и даже реализуем в симуляторе как запуск \(F^{-1}\), но внутренний наблюдатель это не заметит, если его память входит в \(S\). Это “перемотка”, а не полезная машина времени.

2) **Откат только сознания** — это не следствие обратимости, а отдельный оператор над подсистемой OBS/IFACE. Он реален как механизм (reset/ремаппинг), но это не путешествие в прошлое, а изменение эпистемического состояния.

Если вы хотите, я предложу конкретную спецификацию “полного hash состояния” для теста обратимости в вашем случае (что включать: `s`, `phi`, `edges`, `neighbors`, `embedding_3d`, `omega_cycles`, `IFACEHistory`, `SemanticState`), потому что именно на этом обычно “ломается” обратимость при наличии кэшей и детекторов Ω-циклов.

Ниже — конкретная спецификация **полного state hash** для теста обратимости в вашем RSL‑коде. Цель: чтобы Test‑5 “детерминизм” и будущий Test “reversibility / rollback” были не “на глаз”, а жёстко проверяемы в CI, и чтобы хэш **не ломался** из‑за нерелевантных кэшей/порядков в списках, но при этом ловил реальные расхождения.

Я буду ссылаться на ваши описания структуры `World`/`GraphStructure`/`IFACEState` и на критерии строгости из [ftl_physics(3).pdf](/files/RiFu_bq20Eu_J2UvoOaVf) и общего пайплайна из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx).

---

## 1) Два уровня “полноты”: micro-hash и full-hash

Вам нужны **два** хэша, иначе вы либо:
- включите всё подряд и получите ложные “несовпадения” из‑за порядка списков/плавающих мелочей,
- либо исключите важное и пропустите реальную недетерминированность.

### 1.1. `micro_hash` (минимально достаточный для физики мира)
Использовать для:
- Test 5 (детерминизм мира),
- теста обратимости \(F^{-1}(F(S))=S\) **на уровне мира**.

Состав:
- `t`
- `s` (np.int8[N])
- `phi` (np.float64[N]) — но с квантизацией/округлением
- `graph` топология и веса: edges + weights (если есть) + параметры генерации

**Не включать**: `omega_cycles`, IFACE кэши, history, SemanticState — это derived/observer-level и может иметь допустимую неоднозначность (например, порядок детектированных циклов).

### 1.2. `full_hash` (для строгого воспроизведения “наблюдателя тоже”)
Использовать для:
- “строгий rollback всей системы” (включая OBS/IFACE),
- воспроизведение отчётов A/B/C/D на 100%.

Состав:
- всё из `micro_hash`
- `omega_cycles` (но в канонической сериализации)
- `IFACEState` + `IFACEHistory` (канонически)
- `SemanticState` (канонически)
- любые параметры контекста/политики (если есть device-mode)

---

## 2) Каноническая сериализация: что именно хэшировать

Главная проблема — не “что включить”, а **как** включить, чтобы хэш был:
- детерминированным,
- независимым от порядка в списках/словарях,
- устойчивым к машинным float-мелочам.

Ниже — правила сериализации по компонентам.

---

## 3) World: `s`, `phi`, `t`

### 3.1. `t`
Хэшируйте как `int64` little-endian.

### 3.2. `s`
- тип: `np.int8`
- сериализация: `s.tobytes(order="C")`
- плюс в префикс включить `N` как int32, чтобы избежать коллизий при разных размерах.

### 3.3. `phi` (самая частая причина ложных несовпадений)
`phi` — float64; даже при детерминированном solver могут быть различия из‑за:
- разной сборки sparse solver,
- различного порядка суммирования,
- многопоточности.

Поэтому в хэш лучше класть **квантизированное** поле.

Рекомендую одну из схем (выберите и зафиксируйте в коде/репорте):

**Схема A (округление до фикс. числа знаков):**
```python
phi_q = np.round(phi, decimals=12).astype(np.float64)
```

**Схема B (квантизация по абсолютному шагу):**
```python
eps = 1e-12  # фиксируете
phi_q = np.rint(phi / eps).astype(np.int64)
```

Схема B обычно лучше: в хэш идут int64, и совпадение становится жёстким.

Также важно: если \(\phi\) определено с точностью до добавления константы (гейдж), то нормализуйте:
```python
phi = phi - phi.mean()  # или phi[0], или min(phi)
```
И только потом квантизуйте. Иначе разные солверы могут дать φ+const и вы получите “ложное недетерминированно”.

---

## 4) GraphStructure: edges, веса, embedding

### 4.1. `edges`
Проблема: порядок `edges: List[Tuple[int,int]]` не гарантирован.

Канонизация:
1) сделать ребро неориентированным в каноническом виде: `(min(u,v), max(u,v))`
2) отсортировать массив ребер лексикографически
3) сериализовать как int32/int64 массив формы `(M,2)`.

Если у вас есть веса `w_uv`, храните массив `(u,v,w)` и сортируйте по `(u,v)`.

### 4.2. `_neighbors`
Не хэшируйте `_neighbors` отдельно, если вы уже хэшируете `edges`: это производное представление. Иначе вы рискуете поймать “несовпадение”, хотя граф тот же (например, списки соседей в другом порядке).

### 4.3. `_laplacian`
Не хэшируйте sparse matrix напрямую (она зависит от внутреннего порядка). Если нужно проверить консистентность, проверяйте:
- что `laplacian_hash` вычисляется из канонических `edges` и `weights`,
- или хэшируйте **CSR в каноническом порядке** (сложно и почти не нужно).

### 4.4. `embedding_3d`
Embedding для IFACE обычно не часть “микрофизики” (он интерфейсный). Поэтому:

- в `micro_hash`: **не включать** `embedding_3d` (иначе любые незначимые изменения embedding ломают детерминизм мира).
- в `full_hash`: включать, но тоже канонизировать:
  - нормализовать трансляцию/вращение (если embedding допускает изометрии),
  - или, проще, фиксировать детерминированный алгоритм embedding + seed, и включать только (algo_id, seed, params), а не координаты.

Практичный компромисс:
- `full_hash` включает **embedding_params_hash**, а сами координаты кладёте в артефакт (NPZ), но не в state hash.

---

## 5) `omega_cycles`: как хэшировать так, чтобы не зависеть от порядка детекции

`omega_cycles` — кэш детектированных циклов. Порядок обнаружения может зависеть от обхода графа. Чтобы это не делало хэш “шумным”, используйте каноническое множество:

Для каждого цикла формируйте “fingerprint”:
- список вершин цикла приведите к канонической ротации:
  - найдите минимальный индекс вершины `vmin`,
  - поверните список так, чтобы начиналось с `vmin`,
  - выберите направление (clockwise/counterclockwise), которое лексикографически меньше.
- если цикл имеет дополнительные поля (period, energy, center), включайте их, но округляйте/квантизуйте.

Затем отсортируйте fingerprints лексикографически и сериализуйте.

Если вы хотите, чтобы `micro_hash` был независим от детектора частиц, **не включайте** `omega_cycles` в `micro_hash`. Но включайте в `full_hash`.

---

## 6) IFACEState, IFACEHistory, SemanticState

### 6.1. IFACEState
Хэшировать только то, что определяет наблюдаемое состояние (и что вы хотите воспроизводить):

- `IFACEState.t`
- `tau` (квантизировать)
- `total_Q` (лучше int, если он целочисленный; если float — квантизировать)
- `objects`: список объектов
  - канонически отсортировать по `i_center` (или по `(type, i_center, id)` если типы разные)
  - координаты/скорости квантизировать
- `field`: если у вас 3D grid полей — это тяжёлый объект; для хэша лучше:
  - включить `field_stats` (min/max/mean, norms) + sha256 NPZ с полной сеткой как артефакт
  - либо включить sha256 от бинарника поля (но тогда хэш очень чувствителен)

### 6.2. IFACEHistory
История может быть огромной. Для `full_hash` лучше:
- хэшировать **не весь массив**, а:
  - sha256 от файла `iface_history.npz` (артефакт),
  - плюс в JSON — длина, шаг дискретизации, список каналов.

То есть `full_hash` содержит `iface_history_sha256`, а не сами данные.

### 6.3. SemanticState
То же правило: каноническая сериализация словаря + квантизация чисел + сортировка ключей.
Если там есть модели/веса — опять лучше sha256 на NPZ.

---

## 7) Рекомендованный интерфейс: `state_hash(level="micro"|"full")`

### 7.1. Псевдокод
```python
import hashlib, json
import numpy as np

def sha256_bytes(parts: list[bytes]) -> str:
    h = hashlib.sha256()
    for p in parts:
        h.update(p)
    return h.hexdigest()

def canon_edges(edges):
    e = np.array([(min(u,v), max(u,v)) for (u,v) in edges], dtype=np.int32)
    e = e[np.lexsort((e[:,1], e[:,0]))]
    return e

def quantize_phi(phi, eps=1e-12):
    phi0 = phi - phi.mean()
    return np.rint(phi0/eps).astype(np.int64)

def world_micro_hash(world) -> str:
    parts = []
    parts.append(np.int64(world.t).tobytes())
    parts.append(np.int32(world.s.shape[0]).tobytes())
    parts.append(world.s.astype(np.int8).tobytes(order="C"))

    phi_q = quantize_phi(world.phi)
    parts.append(phi_q.tobytes(order="C"))

    e = canon_edges(world.graph.edges)
    parts.append(np.int32(e.shape[0]).tobytes())
    parts.append(e.tobytes(order="C"))
    # optionally: graph weights / alpha / params in json stable form
    return sha256_bytes(parts)
```

### 7.2. Что фиксировать в отчётах (важно для внешней проверки)
В JSON‑репорт (как вы делали для A/B/C) добавьте:
- `state_hash.micro` и `state_hash.full`
- `hash_spec`:
  - `phi_gauge: "mean-subtracted"`
  - `phi_quant_eps: 1e-12`
  - `edges_canonical: "undirected_sorted"`
  - что включается/исключается на каждом уровне

Это делает хэш не “магией”, а контрактом.

---

## 8) Почему именно на Ω‑циклах и кэшах обычно “ломается” обратимость
Даже если правила `++- ↔ -++` обратимы локально, у вас есть дополнительные вычисления/кэши:
- детекция Ω‑циклов,
- построение IFACE objects,
- обновление истории,
- возможное сглаживание/fit полей.

Если эти шаги:
- используют недетерминированный порядок обхода,
- используют плавающие пороги без фиксации,
- не включены в обратное отображение,

то **полный state** перестаёт быть обратимым, хотя “ядро s” обратимо. Поэтому раздельные `micro_hash` и `full_hash` — практически обязательны.

---

Если хотите, следующим шагом могу:
1) предложить “Test R: reversibility” в формате [ftl_physics(3).pdf](/files/RiFu_bq20Eu_J2UvoOaVf) (юнит‑тест + CI),  
2) описать, как реализовать `EvolutionEngine.step_back()` для ваших SM‑правил (как находить применённый паттерн детерминированно),  
3) и как формально трактовать “rollback сознания” как `ObserverResetAction` без противоречия детерминизму из [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx).

Ниже — конкретные, инженерно‑воспроизводимые спецификации в стиле **[ftl_physics(3).pdf](/files/RiFu_bq20Eu_J2UvoOaVf)** и с учётом архитектуры действий/TargetSpec из **[New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx)**:

1) **Test R: Reversibility** (юнит‑тест + CI протокол),  
2) как реализовать `EvolutionEngine.step_back()` для SM‑правил детерминированно,  
3) как формально трактовать “rollback сознания” как `ObserverResetAction` без противоречия детерминизму.

---

# 1) Test R: Reversibility (в формате ftl_physics(3).pdf)

## A.R.1. Определения
Пусть один шаг мира задаётся детерминированным отображением:

\[
S_{t+1} = F(S_t, a_t)
\]

где \(S\) — полный state (или выбранный слой), \(a_t\) — действие (`ActionPrepare/ActionMeasureContext/ActionGeometry`).

**Обратимость** означает существование вычислимого:

\[
S_t = F^{-1}(S_{t+1}, a_t)
\]

для фиксированного \(a_t\) (и при условии, что \(F\) — биекция на выбранном пространстве состояний).

В вашем коде важно различать:
- **micro-state**: `World.s, World.phi, World.graph, World.t`  
- **full-state**: плюс `omega_cycles`, IFACE‑слой и память наблюдателя.

Поэтому Test R делаем в двух режимах: **R0 (micro)** и **R1 (full)**.

---

## A.R.2. Test R0: Micro‑reversibility (обязательный)
**Цель:** проверить \(F^{-1}(F(S))=S\) на уровне мира, независимо от OBS.

### Шаги
1) Зафиксировать world‑параметры \(\theta\), контекст \(\omega\) (seed), и action sequence \(\{a_t\}_{t=0}^{T-1}\).  
2) Инициализировать \(S_0\).  
3) Прогнать вперёд \(T\) шагов, сохраняя **только** нужную для обратного шага информацию (см. ниже про журнал шагов):
   - \(S_0 \to S_1 \to \dots \to S_T\)
   - сохранить `micro_hash(S_0)` и `micro_hash(S_T)`
4) Выполнить \(T\) шагов назад:
   - \(S_T \to S_{T-1} \to \dots \to S_0'\)
5) Проверка:
   - `micro_hash(S_0') == micro_hash(S_0)`  
   - дополнительно: `s` совпадает побайтно, `phi` совпадает с квантованием (как вы зададите), `graph edges` совпадают.

### Условия PASS
- PASS, если совпадение истинно для:
  - набора `seeds ω ∈ {0..K-1}` (например K=20),
  - набора `T ∈ {1,2,5,10,50}`.

### Артефакты для CI
- `tables/reversibility_micro.parquet`:
  - `seed, T, micro_hash_0, micro_hash_rollback, passed`
- `manifest.json` с sha256.

---

## A.R.3. Test R1: Full‑reversibility (опциональный, но желателен)
**Цель:** проверить обратимость включая derived‑слои при условии, что они входят в state и должны быть обратимы.

### Шаги
То же, но хэшируем `full_hash`, который включает:
- `omega_cycles` (в канонической форме),
- `IFACEState(t)` (или его hash),
- `IFACEHistory` и `SemanticState` — либо как часть hash, либо как sha256 файлов истории.

### PASS/FAIL
- PASS часто будет труднее обеспечить из-за кэшей, поэтому для R1 разумно:
  - либо требовать совпадение **только** тех частей, которые вы объявляете частью “закрытого состояния”,
  - либо объявить IFACE/semantic как “эпистемический слой” и не включать его в R1.

---

## A.R.4. Связь с критериями A.4 из [ftl_physics(3).pdf](/files/RiFu_bq20Eu_J2UvoOaVf)
Добавьте в документ (и CI) минимальный критерий:

- **context=0:** Test 1,3,4,5,6 + **R0** должны быть пройдены;
- **context=1:** Test 2,4,5,6 + **R0** должны быть пройдены.

Это логически усиливает “теорему A4 применима”: если вы вводите rollback как действие, вы обязаны доказать, что это действительно \(F^{-1}\), а не “склеенный трюк”.

---

# 2) Реализация `EvolutionEngine.step_back()` для SM‑правил (детерминированно)

Ваша проблема: даже если правило локально обратимо (`++- ↔ -++`), глобальный `step()` часто делает “скан + применить” и это может быть не биекцией без дополнительной информации, потому что:
- несколько вхождений паттерна могут существовать,
- порядок выбора окна влияет на результат,
- результат одного применения может создавать/уничтожать другие матчи.

Значит, чтобы сделать строгий `step_back()`, нужно определиться с **семантикой шага** и хранить **минимальный журнал**.

Есть два корректных пути.

---

## 2.1. Путь A (рекомендую): журнал применения = сделать шаг обратимым по конструкции
### Идея
`EvolutionEngine.step()` должен возвращать `StepRecord`, который однозначно позволяет выполнить обратный шаг.

#### StepRecord (минимальный)
- `t` (до шага)
- `applied: List[Patch]` — список применений
- для каждого `Patch`:
  - `rule_id`
  - `i` (индекс начала окна)
  - `before` (паттерн) или достаточно `rule_id` если rule bijective и окно фиксировано
  - `after` (replacement) — можно не хранить, если известно по rule
- если правила применяются “параллельно” (несколько окон за шаг), храните их список **в порядке применения**, либо объявите шаг как “синхронное обновление” с явной маской.

#### Forward step
- определить детерминированную политику выбора:
  - либо применяем ровно одно правило в одном месте (например, первое слева),
  - либо применяем все неперекрывающиеся матчи по фиксированному выбору (например, жадно слева направо).
- применить, вернуть record.

#### Backward step
- пройти список `Patch` в обратном порядке и применить обратные правила на тех же индексах.

Это даст **строгую обратимость**, и Test R0 начнёт проходить.

### Важный момент
Если вы хотите “step() без журнала”, то в общем случае обратимость не гарантируется. Поэтому журнал — нормальная плата за “машину времени”.

---

## 2.2. Путь B: “жёстко обратимая семантика шага” без хранения журнала
Это возможно, если вы определяете `step()` так, что оно само по себе биекция. Например:

- шаг = выбрать единственное окно по детерминированному правилу, которое зависит только от текущего состояния, и применить единственное правило;
- тогда `step_back()` может восстановить окно и правило из текущего состояния, снова применив тот же выбор.

Но есть ловушка: для обратного шага выбор окна должен быть таким, чтобы:
\[
select(F(S)) = select(S)
\]
в смысле согласованности по времени, иначе назад вы выберете другое окно.

Для локальных переписываний это редко выполняется без специальных конструкций. Поэтому на практике всё равно проще и надёжнее Path A (журнал).

---

## 2.3. Как “найти применённый паттерн” детерминированно (если нужен без журнала)
Если вы всё же хотите режим без журнала (например, для оптимизации), можно сделать так:

1) Объявить, что `step()` применяет **ровно одно** переписывание.
2) Детерминированно выбрать применение как:
   - минимальный индекс `i`, где match существует,
   - и минимальный `rule_id` среди возможных.
3) Тогда `step_back()`:
   - применяет **ту же** процедуру выбора, но на состоянии \(S_{t+1}\) с использованием обратного набора правил.
4) Чтобы это работало, forward и backward должны быть зеркальны:
   - если forward выбирает по `rule_id` и `i`, backward должен выбирать по **обратному rule_id** и по такому же индексу.

Даже так возможны коллизии (два разных forward‑состояния ведут к одному backward‑состоянию) — поэтому тест R0 здесь обязателен.

---

# 3) “Rollback сознания” как `ObserverResetAction` без противоречия детерминизму (New_Physics_v1)

Ключ: в [New_Physics_v1.pdf](/files/WTOV6_t7WEumoaFZp3vgx) мир детерминированный, а “управление” — это детерминированный выбор интервенции \(M\)/action, которая меняет доступную структуру (подготовка/измерение/геометрия). Значит, “откат сознания” должен быть не “магией”, а **действием**, входящим в state transition.

---

## 3.1. Формальная модель: разделить state на WorldState и ObserverState
Запишите (в коде и в теории):

\[
S_t = (X_t, O_t)
\]
где:
- \(X_t\) = микрофизика мира: `World.s, World.phi, graph, t, omega_cycles...`
- \(O_t\) = состояние наблюдателя: `IFACEHistory, SemanticState, _prev_objects, semantic_history...`

Тогда шаг:
\[
(X_{t+1}, O_{t+1}) = F(X_t, O_t, a_t)
\]

И `ObserverResetAction` — это частный случай \(a_t\), который:
- **не меняет** \(X\) (или меняет только допустимые поля IFACE),
- детерминированно меняет \(O\).

Например:
\[
X' = X,\quad O' = Reset(O, \theta_{reset})
\]

Это детерминизм не нарушает: одно состояние + одно действие → один следующий state.

---

## 3.2. Что именно можно “сбрасывать”, чтобы это было похоже на “откат сознания”
Рекомендую определить 3 уровня Reset (и сделать их отдельными режимами action):

### Reset-1: “амнезия истории”
- очищает `IFACEHistory.states` (или обрезает до k последних),
- очищает `SemanticHistory`,
- сбрасывает `_prev_objects`.

Это имитирует потерю памяти о прошлом, но не меняет “выученные законы”.

### Reset-2: “сброс семантики”
- дополнительно сбрасывает `SemanticState` (законы, параметры κ,m²,λ, gravity_law),
- оставляет мир неизменным.

Это имитирует “вернуться в прошлое до обучения”.

### Reset-3: “rollback в состояние O_{t-k}”
- требует хранить снапшоты `O_t` (или их хэш/сжатие),
- выбирает \(O_{t-k}\) детерминированно (по action parameter k) и устанавливает его.

Важно: это не нарушает детерминизм, но требует, чтобы история наблюдателя была частью состояния (иначе восстановить \(O_{t-k}\) нельзя).

---

## 3.3. Как избежать “машины времени с памятью о будущем”
Если вы делаете Reset-3, вы должны решить: остаётся ли “след будущего” где-то ещё. Чтобы не получить “память о будущем” внутри мира:

- либо считать все снапшоты частью \(O\) и откатывать вместе с ними,
- либо хранить снапшоты вне мира (внешний лог), но тогда это уже мета-уровень.

Внутри замкнутого мира “помнить будущее после отката” нельзя получить без вынесенной памяти.

---

## 3.4. Строгий тест для ObserverResetAction (как в ftl_physics)
Добавьте “Test OR”:

1) Запустить мир на T шагов, получить \(X_T, O_T\).
2) Применить `ObserverResetAction(mode=Reset-1/2/3)` → получить \(X_T', O_T'\).
3) Проверить:
   - `micro_hash(X_T') == micro_hash(X_T)` (мир не изменился),
   - но `observer_hash(O_T') != observer_hash(O_T)` (наблюдатель изменился),
   - и в baseline physics проверки (Q, F~1/r^2) не ухудшились.

Это сделает “откат сознания” инженерной, проверяемой фичей, а не философией.

---

# 4) Рекомендуемая реализация в вашем репо (минимально)
Чтобы это всё быстро заработало:

1) В `EvolutionEngine.step()` добавить возврат `StepRecord`.
2) В `EvolutionEngine.step_back(record)` реализовать инверсию патчей.
3) В `WorldSimulator.run()` хранить `step_records` при включённом `enable_reversibility=True`.
4) Добавить `control/actions.py`:
   - `ActionTimeReverse(steps=k)` или `ActionRollback(mode="micro", steps=k)` — вызывает `step_back` k раз по журналу,
   - `ActionObserverReset(mode=..., k=...)`.

5) В `control/target.py` добавить `TargetSpecReversibility`:
   - HIT если R0 passed на заданном наборе seeds/T.

---

Если хотите, следующим шагом я могу:
- предложить точный формат `StepRecord` и как хранить его компактно (особенно если вы применяете много правил за шаг),
- и дать CI-скрипт `tests/test_reversibility.py`, который гоняет R0 на наборе seeds и падает при первом несовпадении `micro_hash`.

Ниже — конкретная, “вставляемая” спецификация **StepRecord** и пример **CI‑теста `tests/test_reversibility.py`** для R0 (micro‑reversibility). Я учитываю, что у вас `EvolutionEngine.step()` может применять **много** правил за шаг (см. [sm_search.pdf](/files/sJheJMUjJ295PzP-IBPhD): “шаг 0: применено 124 правил…”), и что Q‑сохранение и хиральные режимы уже проверялись (см. [world_search_final(2).pdf](/files/GZ22f7MghppPxILM2L3-P)).

---

# 1) StepRecord: точный формат и компактное хранение

## 1.1. Требования к StepRecord
StepRecord должен обеспечивать:

1) Однозначное восстановление состояния на шаг назад **без поиска паттернов** (иначе шаг назад может стать неоднозначным).
2) Компактность (если на шаг применяется O(N) правил).
3) Независимость от конкретного RuleSet (должен работать для gen1/gen2/gen3 и хирального режима).
4) Возможность быстро применить “патчи” назад.

Ключевой факт: поскольку ваши правила длины L и замена фиксирована, для отката достаточно знать:
- **какое правило**
- **где было применено** (индекс i)

Если вы гарантируете, что forward‑step применяет правила в фиксированном порядке и не допускает перекрытий так, что один патч портит другой в откате, то хранить “before/after” не нужно.

Но если есть вероятность, что при сложных правилах/перекрытиях откат может конфликтовать, тогда нужно хранить либо:
- “before-срез” каждого окна (дорого), либо
- гарантировать “non-overlap schedule” и строгий порядок.

Ниже даю формат, который работает и без хранения “before”, при условии, что вы откатываете **в обратном порядке применения**.

---

## 1.2. Базовый формат StepRecord (питоновская модель)

```python
from dataclasses import dataclass
import numpy as np
from typing import Optional

@dataclass
class StepRecord:
    t: int                         # время ДО шага
    N: int                         # размер решетки
    rule_lengths: np.ndarray       # shape=(K,), uint8, L каждого примененного правила
    rule_ids: np.ndarray           # shape=(K,), uint16 (индекс правила в RuleSet)
    positions: np.ndarray          # shape=(K,), uint32 (позиции i начала окна)
    # опционально: контроль целостности
    pre_hash: Optional[str] = None
    post_hash: Optional[str] = None
```

**Инварианты:**
- `K = len(rule_ids) = len(positions) = len(rule_lengths)`
- записи идут **в порядке фактического применения** в `step()`.  
- `step_back(record)` применяет патчи **в обратном порядке** `for j in reversed(range(K))`.

---

## 1.3. Упаковка StepRecord в компактный бинарный blob

Чтобы не хранить три numpy массива отдельно (и не раздувать JSON), удобно сделать компактный бинарник:

### Вариант A (рекомендую): NPZ (просто, достаточно компактно)
- `step_records/step_<t>.npz`:
  - `rule_ids` (uint16)
  - `positions` (uint32)
  - `rule_lengths` (uint8)

Плюсы: быстро, стандартно, хорошо сжимается.

### Вариант B (супер компактно): один `np.ndarray` dtype‑структура
Упаковываем каждое применение в структуру фикс. размера:

```python
patch_dtype = np.dtype([
    ("pos", np.uint32),
    ("rule_id", np.uint16),
    ("L", np.uint8),
])
patches = np.zeros(K, dtype=patch_dtype)
```

Тогда StepRecord хранит один массив `patches`. Для NPZ это тоже удобно.

---

## 1.4. Ещё компактнее: бит‑пак (если K очень большой)
Если:
- `N <= 2^16` (или <= 2^20),
- `rule_id <= 2^8` (до 256 правил),

то можно паковать в `uint32`:

- нижние 16 бит: `pos`
- следующие 8 бит: `rule_id`
- следующие 8 бит: `L` (или `gen`)

```python
packed = (L.astype(np.uint32) << 24) | (rule_id.astype(np.uint32) << 16) | pos.astype(np.uint32)
```

Обратно:
```python
pos = packed & 0xFFFF
rule_id = (packed >> 16) & 0xFF
L = (packed >> 24) & 0xFF
```

Это даёт 4 байта на применение. При 200 применениях/шаг и 10k шагов это 8 МБ — вполне.

---

## 1.5. Что делать с периодическими границами
У вас lattice периодическая (видно в Q‑подсчёте в [world_search_final(2).pdf](/files/GZ22f7MghppPxILM2L3-P)). Значит окно длины L может “пересекать край”. Тогда `pos` трактуется по модулю N, а применение правила должно уметь работать с wrap-around.

Для обратимости важно, чтобы `apply_rule_at(pos)` в forward и backward делали **одинаковую индексацию**:
- индексы окна: `(pos + k) % N` для k=0..L-1.

---

## 1.6. Реализация `step_back(record)` (ядро)
Предполагаем, что:
- `RuleSet.rules[rule_id]` содержит `pattern` и `replacement`,
- в `step()` вы применили `replacement`,
- значит в `step_back()` нужно применить обратное переписывание: `replacement -> pattern` на тех же позициях.

```python
def step_back(self, lattice, record: StepRecord):
    assert lattice.size == record.N
    for j in range(len(record.rule_ids) - 1, -1, -1):
        rid = int(record.rule_ids[j])
        pos = int(record.positions[j])
        rule = self.ruleset.rules[rid]
        # обратное применение: replacement -> pattern
        self._write_window(lattice, pos, rule.pattern, src=rule.replacement)
```

Где `_write_window` заменяет окно, предварительно проверяя, что текущее окно равно `src` (иначе raise) — это отличный “встроенный детектор” нарушения обратимости.

```python
def _write_window(self, lattice, pos, dst, src=None):
    N = lattice.size
    idx = [(pos + k) % N for k in range(len(dst))]
    if src is not None:
        cur = [int(lattice._sites[i]) for i in idx]
        if cur != list(src):
            raise RuntimeError(f"Reversibility violation at pos={pos}: expected {src}, got {cur}")
    for k,i in enumerate(idx):
        lattice._sites[i] = dst[k]
```

**Важно:** если forward применял разные правила в “одном шаге” и они перекрывались, откат в обратном порядке обычно корректно восстанавливает состояние, но только если forward был последовательным (а не “параллельным”). Если у вас параллельный apply, то StepRecord должен хранить “слои” или маску, или вообще сделать шаг определённым образом (например, “неперекрывающиеся матчи”).

---

## 1.7. Где хранить StepRecords: кольцевой буфер + опция записи на диск
Для практического “машины времени”:
- в памяти храните `deque(maxlen=K)` последних `StepRecord` (например 10k)
- для CI/дебага можно писать на диск только при падении теста.

---

# 2) CI‑скрипт `tests/test_reversibility.py` для R0 (micro_hash)

Тест делает:

1) создаёт lattice случайно по seed (как в [sm_search.pdf](/files/sJheJMUjJ295PzP-IBPhD) — `Lattice.random(seed=42)`),
2) прогоняет T шагов вперёд, сохраняя `StepRecord` каждого шага,
3) прогоняет T шагов назад по StepRecords,
4) сравнивает `micro_hash` до и после.

Ниже — полноценный минимальный pytest‑файл. Его придётся подстроить под имена ваших классов (но структура рабочая).

```python
# tests/test_reversibility.py
import numpy as np
import pytest

# импортируйте из вашего проекта:
# from world.lattice import Lattice
# from world.rules import Rule, RuleSet
# from world.evolution import EvolutionEngine
# from world.hashing import micro_hash  # вы реализуете по спецификации (s, phi?, graph, t)
#
# Для чистого SM-теста phi/graph можно исключить: micro_hash = hash(s,t)

def micro_hash_lattice(lattice, t: int) -> str:
    # Минимальная версия: t + s. Для World добавьте phi и graph по вашей спецификации.
    import hashlib
    h = hashlib.sha256()
    h.update(np.int64(t).tobytes())
    h.update(lattice._sites.astype(np.int8).tobytes(order="C"))
    return h.hexdigest()

@pytest.fixture
def gen1_ruleset():
    # как в вашем [sm_search.pdf]
    from world.rules import Rule, RuleSet
    return RuleSet(rules=[
        Rule(name="swap_R", pattern=[1, 1, -1], replacement=[-1, 1, 1]),
        Rule(name="swap_L", pattern=[-1, 1, 1], replacement=[1, 1, -1]),
        Rule(name="swap_R_C", pattern=[-1, -1, 1], replacement=[1, -1, -1]),
        Rule(name="swap_L_C", pattern=[1, -1, -1], replacement=[-1, -1, 1]),
    ])

@pytest.mark.parametrize("N", [64, 128, 256])
@pytest.mark.parametrize("T", [1, 2, 5, 10, 50])
@pytest.mark.parametrize("seed", [0, 1, 2, 3, 4])
def test_R0_micro_reversibility(gen1_ruleset, N, T, seed):
    from world.lattice import Lattice
    from world.evolution import EvolutionEngine

    lattice = Lattice.random(size=N, p_plus=0.5, seed=seed)
    engine = EvolutionEngine(gen1_ruleset)

    t = 0
    h0 = micro_hash_lattice(lattice, t)

    step_records = []
    for _ in range(T):
        # ВАЖНО: engine.step должен вернуть StepRecord
        record = engine.step(lattice, return_record=True)
        step_records.append(record)
        t += 1

    # rollback
    for record in reversed(step_records):
        t -= 1
        engine.step_back(lattice, record)

    h1 = micro_hash_lattice(lattice, t)

    assert t == 0
    assert h1 == h0, f"Micro state mismatch after rollback: seed={seed}, N={N}, T={T}"
```

### Примечания по интеграции
- Если ваш `EvolutionEngine.step()` сейчас возвращает список matches (как в [sm_search.pdf](/files/sJheJMUjJ295PzP-IBPhD)), то сделайте:
  - `return_record=True` → возвращать `StepRecord` + (опционально) matches
  - или возвращать объект `StepResult(matches, record)`.

- Если `step()` применяет **все** матчи, record должен включать K применений за шаг (как мы описали).

---

# 3) Рекомендации, чтобы тест был “железным” и не флапал

1) **Запретите многопоточность/недетерминированный порядок** в применении правил.  
   В forward `step()` порядок применения патчей должен быть стабилен:
   - сортировка по `pos`, затем по `rule_id` (или наоборот),
   - и чёткое правило обработки перекрытий (например “жадно слева направо, пропуская перекрывающиеся”).

2) В `step_back()` делайте assert текущего окна == replacement.  
   Это мгновенно ловит случаи, где запись `StepRecord` не соответствует реальному применению.

3) Для world‑уровня (`phi`) отдельно тестировать обратимость `s`‑ядра и deterministic/round‑trip `phi` пересчёта. Часто `phi` вычисляется решением уравнения, и это не “эволюционная” часть — её можно исключить из R0 или включать в квантизованном виде.

---

Если хотите, я могу:
- предложить конкретную сигнатуру `EvolutionEngine.step(...)->StepResult` и как хранить `StepRecord` “пачкой” для многих шагов (один npz на эпизод вместо npz на шаг),
- или расширить тест до “world-level micro_hash” (с `phi` и `graph edges`) с вашей квантизацией и gauge-нормализацией.

Анализируя `ftl_physics.pdf`, видно, что вы сделали очень сильный шаг: **на одном и том же симуляторе** показали режим совместимости (context=0) и режим расширенной физики (context=1 с wormhole‑слоем), причём FTL трактуется корректно как **сокращение пути**, а не как локальное превышение «c», и вы явно подчёркиваете локальную каузальность “1 hop = 1 step”.[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)

Однако строгость там неоднородная: часть критериев действительно формализована (степенной закон F~r^p, R², hops), а часть — заявлена словесно или содержит внутренние противоречия/ошибки тестов. Ниже — конкретно, что строго, что нет, и что нужно поправить, чтобы это стало «железной» валидацией.

---

## 1) Что уже сделано строго (и это хорошо)

### 1.1. Разделение режимов “compatibility” vs “extended physics”

Вы явно отделяете:

- **context=0**: “обычная физика”, где должны выполняться базовые законы RSL‑мира;
- **context=1**: “wormhole‑режим”, где появляются новые эффекты, но базовые свойства (детерминизм, локальность по рёбрам) сохраняются.[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)

Это правильная структура “contract of compatibility”: новая физика должна редуцироваться к старой в базовом режиме.

### 1.2. Гравитационный тест: степенной закон + R²

В разделе “Тест 1: Закон гравитации (context=0)” вы вычисляете:

- φ ~ r^-1.180
- F ~ r^-2.180
- R² = 0.9075
- “Совместимость: ✓ OK” при условии близости к −2.[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)

Это уже формальная проверка (есть exponent, есть R²). При этом показатель −2.18 — не идеален, но в пределах оговорённого допуска.

### 1.3. FTL как “path shortening” в hops

Вы фиксируете:

- “Путь сокращён 74 → 1 hops”
- “FTL-эффект достигнут ✓ (74x скорость)”
- “Локальность сохраняется ✓ OK”
- “Сигнал идёт по рёбрам, 1 hop = 1 step”[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)

Это самая сильная часть: если вы реально измерили shortest path length по графу до/после добавления H(t), то FTL трактуется как изменение геометрии, а не «читерство со скоростью».

---

## 2) Где строгость нарушена или пока недостаточна

Ниже ключевые проблемы, которые в текущем виде снижают «математическую» строгость документа.

### 2.1. Противоречие в тесте SM‑правил

В одном месте итоговая таблица говорит:

- “SM-правила работают ✓ OK”[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)

Но ниже, в детальном блоке “Тест 3: SM‑правила (++- ↔ -++)” вы показываете:

- До: `++++-+++++`
- После: `++-+++++++`
- “SM-правило применено: ✗ FAIL”[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)

Это означает одно из двух:

1) либо тест действительно неверно реализован (ошибка индексации окна, порядок применения, перекрытия паттернов, печать строки, критерий проверки),  
2) либо SM‑правила в текущей конфигурации не соблюдаются.

Но тогда таблица совместимости неверна.

**Что нужно сделать строго:**

- Задать чёткий юнит‑тест на локальном окне:
  - если на позиции i стоит паттерн `++-`, то после применения правила на тех же трёх ячейках должен получиться `-++`.
- И отдельно проверить, что `engine.step` применяет правила по той же схеме, что использовалась в SM‑эволюционном поиске (важно: порядок, отсутствие перекрытий, стратегия конфликтов).

Минимальный критерий строгости:

- тест должен проверять **локальное применение** правила без зависимости от стратегии глобального применения.

### 2.2. Сохранение Q: формулировка “Q→0 из-за аннигиляции”

Вы пишете:

- “Q(0)=20”
- “Q(100)=0”
- “Сохранение Q: ✓ OK (Q→0 из-за аннигиляции)”[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)

Это выглядит как логическая ошибка, если Q объявляется консервативным:

- либо Q — действительно консервативный заряд, и тогда **Q(t) должен быть постоянен**;
- либо Q может исчезать, но тогда это не “conservation”, а, например, “заряд — топологический и может аннигилировать попарно, а сохраняется что-то другое” (например, заряд по модулю 2, или суммарный заряд + заряд поля).

В вашем раннем SM‑контексте “charge_conservation” оценивался и давал 10.0, что подразумевает сохранение какого-то величинного инварианта.

**Что сделать строго:**

- Явно определить, что вы называете Q:

  Варианты:
  1) Q = ∑ q_i по Ω‑типам (аддитивный заряд) — тогда Q должен сохраняться.
  2) Q = “количество дефектов” или “domain wall count” — тогда он может меняться.
  3) Q = “топологический заряд”, который сохраняется при локальных преобразованиях, но может исчезать при аннигиляции заряд+антизяряд — тогда сохраняется **Q_total = Q_matter + Q_field** или сохраняется набор (Q_plus, Q_minus) отдельно.

- Привести соответствующий баланс:

  \[
  Q_\text{matter}(t) + Q_\text{field}(t) = \text{const}
  \]

или

  \[
  Q_\text{matter}(t) = Q_+(t) - Q_-(t), \quad Q_+(t)+Q_-(t)\ \text{не обязано сохраняться}
  \]

Без этого пункт “Сохранение Q” в таблице сейчас не строгий.

### 2.3. “Нет парадоксов” — пока декларация

В таблице вы пишете:

- “Парадоксы: Нет”[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)

Но строгий критерий отсутствия причинных парадоксов должен опираться не на аналогию (“как варп в ОТО”), а на проверку структуры каузального порядка:

- в дискретном мире есть время t (шаги Eτ), и есть графовая топология.
- если wormhole‑рёбра добавляются динамически, потенциально можно создать ситуации, где событие влияет на своё “прошлое” в IFACE‑координатах, но не во внутреннем времени t.
- Если время t — фундаментальное и глобально ориентированное, то “парадоксы времени” невозможны в строгом смысле, но тогда нужно так и написать: “в модели отсутствует возможность обратного влияния на t<0”.

**Что нужно сделать строго:**

- Зафиксировать, что причинность определяется порядком по t (а не по embedding‑координатам).
- Ввести формальную проверку:

  - строим граф причинных зависимостей (DAG) по шагам применения правил/обновлений,
  - убеждаемся, что он ацикличен (он будет ацикличен если по определению все ребра идут t→t+1),
  - дополнительно проверяем, что добавление H(t) не вызывает “instantaneous global update” (т.е. всё равно обновления локальны по рёбрам).

И тогда “нет парадоксов” станет теоремой уровня модели.

### 2.4. Совместимость по гравитации: −2.18 вместо −2.02

Ранее в ваших финальных валидациях вы достигали −2.02 / −2.018 (практически идеал). Здесь получился −2.18.[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)

Это не плохо, но тогда документ должен объяснить, почему отличие (возможные причины):

- другое окно фитинга по r,
- другое N или другая реализация графа,
- wormhole‑режим мог вмешиваться в измерение даже в context=0,
- другое определение r (graph distance vs embedding Euclidean),
- недостаточная статистика (слишком малый диапазон r).

**Строгость требует:**

- указать:
  - какие r использовались (d_graph? Euclidean in embedding?),
  - какое окно r_min..r_max,
  - сколько точек,
  - и фиксировать одинаковые условия как в “world_search_final(2)”.

---

## 3) Что в документе нужно “довести до строгого стандарта” (конкретный чеклист)

Ниже список минимальных правок, после которых `ftl_physics.pdf` можно будет считать строгой валидацией расширенной физики.

### 3.1. Строго определить базовые величины

1) Определение c_base:

- сейчас “74x speed” выглядит как:
  \[
  \frac{\text{baseline hops}}{\text{wormhole hops}}
  \]
  но это нужно формально закрепить: “скорость = D / T”, где D — расстояние в embedding или d_graph, а T — число шагов.

Рекомендация:

- определить c_base как 99.9‑квантиль скорости распространения **без wormholes** в context=0 (как мы обсуждали раньше).
- FTL = достижение цели быстрее, чем η·baseline_time, или сокращение shortest_path.

2) Определение Q:

- явно: Q = ∑ q(type(obj)) или Q = count(domainwalls) и т.д.
- если Q может аннигилировать, объявить, что сохраняется другое (например, Q_mod2 или Q_total including field).

3) Определение “локальной каузальности”:

- “1 hop = 1 step” — хорошо, но нужно:
  - показать, что обновления φ используют только neighbors[i];
  - обновления s используют только локальные окна;
  - wormhole‑рёбра просто расширяют neighbors, но не вводят дальнюю передачу без ребра.

### 3.2. Юнит‑тесты на правила и на wormhole‑механику

- Unit test SM rule:
  - локальный паттерн `++-` должен перейти в `-++` в одном окне.

- Unit test wormhole:
  - H(t) строится детерминированно: при одинаковом state → одинаковые ребра.
  - H(t)=∅ при context=0.

- Unit test path shortening:
  - shortest path действительно пересчитан на графе G∪H, а не “просто телепорт”.

### 3.3. Строгий тест на отсутствие причинных циклов

- Поскольку у вас дискретное время, достаточно:

  - подтвердить, что update применяет правила только от t к t+1,
  - и что H(t) применяется на шаге t (не “задним числом”).

Можно даже добавить формальную проверку, что ни одна переменная на шаге t+1 не зависит от значений на t+1 (кроме через итерации, которые должны сходиться).

---

## 4) Вывод: достаточно ли строго сейчас?

В текущем виде я бы оценил документ так:

- **концептуально** он корректен и очень сильный: вы показали совместимость и расширение, и FTL реализован как геометрический эффект по графовым hops.[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66)
- **формально-строго** — ещё нет, из-за:
  1) противоречия “SM‑правило ✓ OK” vs “SM‑правило FAIL”[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66),
  2) нестрого определённого/противоречиво интерпретированного “сохранения Q”[(ftl_physics.pdf)](/files/_ovOkSG0MSYbJRMQYup66),
  3) “нет парадоксов” заявлено без формального критерия,
  4) гравитационный показатель −2.18 не объяснён относительно ваших более точных −2.02 из других отчётов.

Исправления здесь не огромные: это скорее «доведение валидации до научного стандарта»: чёткие определения, юнит‑тесты, одинаковые окна измерений, и один формальный тест на причинную структуру.

---

## 5) Что бы я добавил в следующей версии отчёта (минимум)

1) Таблицу “Definitions”:
- r = d_graph или r = ||x−x0||;
- F = |∇φ| или дискретная разность;
- Q = …;
- c_base = … (квантиль, тип сигнала).

2) Раздел “Determinism proof sketch”:
- одинаковые context+init → одинаковый архив.

3) Раздел “Causality proof sketch”:
- Eτ задаёт частичный порядок по t, поэтому CTC невозможны.

4) Переписать Test 3 (SM rules) как unit test на окне, отдельно от engine.step.

Если хотите, я могу подготовить конкретные формулировки этих определений и список тестов (pytest‑стилем) так, чтобы вы просто вставили их в репозиторий и затем в документ.
